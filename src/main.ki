// Lisp Interpreter - Main Entry Point
// Combines lexer, parser, and evaluator into a working interpreter

// ============================================================================
// Token Types
// ============================================================================

type Token =
    | TokLParen
    | TokRParen
    | TokQuote
    | TokInt(i64)
    | TokFloat(f64)
    | TokString(string)
    | TokSymbol(string)
    | TokBool(bool)
    | TokEOF

type LexResult =
    | LexOk(List[Token])
    | LexErr(string, i32)

// ============================================================================
// Lisp Value Types
// ============================================================================

type LispValue =
    | LispNil
    | LispBool(bool)
    | LispInt(i64)
    | LispFloat(f64)
    | LispString(string)
    | LispSymbol(string)
    | LispList(List[LispValue])
    | LispLambda(List[string], LispValue, Env)
    | LispBuiltin(string)

type Env = {
    bindings: HashMap,
    parent: Option[Env]
}

type ParseResult =
    | ParseOk(LispValue, List[Token])
    | ParseErr(string)

type ParseAllResult =
    | ParseAllOk(List[LispValue])
    | ParseAllErr(string)

type EvalResult =
    | EvalOk(LispValue, Env)
    | EvalErr(string)

// ============================================================================
// Lexer
// ============================================================================

type Lexer = {
    input: string,
    pos: i32,
    length: i32
}

// Helper to get substring (unwrap Option)
fn substr(s: string, start: i32, end: i32) -> string {
    match std.string.substring(s, start, end) {
        Some(result) => { return result }
        None => { return "" }
    }
}

// Helper to get char at index (unwrap Option)
fn char_at(s: string, idx: i32) -> char {
    match std.string.char_at(s, idx) {
        Some(c) => { return c }
        None => { return '\0' }
    }
}

fn lexer_new(input: string) -> Lexer {
    return Lexer {
        input: input,
        pos: 0,
        length: std.string.length(input)
    }
}

fn is_at_end(lex: Lexer) -> bool {
    return lex.pos >= lex.length
}

fn current_char(lex: Lexer) -> char {
    if is_at_end(lex) { return '\0' }
    return char_at(lex.input, lex.pos)
}

fn peek_char(lex: Lexer, offset: i32) -> char {
    let idx: i32 = lex.pos + offset
    if idx >= lex.length { return '\0' }
    return char_at(lex.input, idx)
}

fn advance(lex: Lexer) -> Lexer {
    return Lexer { input: lex.input, pos: lex.pos + 1, length: lex.length }
}

fn skip_whitespace_and_comments(lex: Lexer) -> Lexer {
    var current: Lexer = lex
    loop {
        if is_at_end(current) { break }
        let c: char = current_char(current)
        if c == ' ' or c == '\t' or c == '\n' or c == '\r' {
            current = advance(current)
        } else if c == ';' {
            while not is_at_end(current) and current_char(current) != '\n' {
                current = advance(current)
            }
        } else {
            break
        }
    }
    return current
}

fn is_digit(c: char) -> bool {
    return c >= '0' and c <= '9'
}

fn is_symbol_start(c: char) -> bool {
    return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or
           c == '+' or c == '-' or c == '*' or c == '/' or
           c == '<' or c == '>' or c == '=' or c == '!' or
           c == '?' or c == '_' or c == '&' or c == '%' or
           c == '^' or c == '~' or c == '@' or c == '$'
}

fn is_symbol_char(c: char) -> bool {
    return is_symbol_start(c) or is_digit(c) or c == '.' or c == ':'
}

fn read_number(lex: Lexer) -> (Lexer, Token) {
    var current: Lexer = lex
    let start: i32 = current.pos
    var has_dot: bool = false
    var has_exp: bool = false

    let first: char = current_char(current)
    if first == '+' or first == '-' { current = advance(current) }

    while not is_at_end(current) and is_digit(current_char(current)) {
        current = advance(current)
    }

    if not is_at_end(current) and current_char(current) == '.' {
        let next: char = peek_char(current, 1)
        if is_digit(next) {
            has_dot = true
            current = advance(current)
            while not is_at_end(current) and is_digit(current_char(current)) {
                current = advance(current)
            }
        }
    }

    if not is_at_end(current) {
        let exp_char: char = current_char(current)
        if exp_char == 'e' or exp_char == 'E' {
            has_exp = true
            current = advance(current)
            let sign: char = current_char(current)
            if sign == '+' or sign == '-' { current = advance(current) }
            while not is_at_end(current) and is_digit(current_char(current)) {
                current = advance(current)
            }
        }
    }

    let num_str: string = substr(lex.input, start, current.pos)

    // TODO: Add float parsing when Kira supports it
    // For now, treat all numbers as integers
    match std.string.parse_int(num_str) {
        Some(n) => { return (current, TokInt(n)) }
        None => { return (current, TokInt(0i64)) }
    }
}

fn read_string(lex: Lexer) -> Result[(Lexer, Token), (string, i32)] {
    var current: Lexer = advance(lex)
    var sb: StringBuilder = std.builder.new()

    while not is_at_end(current) {
        let c: char = current_char(current)
        if c == '"' {
            current = advance(current)
            return Ok((current, TokString(std.builder.build(sb))))
        } else if c == '\\' {
            current = advance(current)
            if is_at_end(current) {
                return Err(("Unexpected end in string escape", current.pos))
            }
            let escaped: char = current_char(current)
            match escaped {
                'n' => { sb = std.builder.append_char(sb, '\n') }
                't' => { sb = std.builder.append_char(sb, '\t') }
                'r' => { sb = std.builder.append_char(sb, '\r') }
                '\\' => { sb = std.builder.append_char(sb, '\\') }
                '"' => { sb = std.builder.append_char(sb, '"') }
                _ => { sb = std.builder.append_char(sb, escaped) }
            }
            current = advance(current)
        } else {
            sb = std.builder.append_char(sb, c)
            current = advance(current)
        }
    }
    return Err(("Unterminated string", lex.pos))
}

fn read_symbol(lex: Lexer) -> (Lexer, Token) {
    var current: Lexer = lex
    let start: i32 = current.pos
    while not is_at_end(current) and is_symbol_char(current_char(current)) {
        current = advance(current)
    }
    let symbol: string = substr(lex.input, start, current.pos)
    return (current, TokSymbol(symbol))
}

fn looking_at_number(lex: Lexer) -> bool {
    let c: char = current_char(lex)
    if is_digit(c) { return true }
    if (c == '+' or c == '-') {
        let next: char = peek_char(lex, 1)
        return is_digit(next)
    }
    return false
}

fn next_token(lex: Lexer) -> Result[(Lexer, Token), (string, i32)] {
    var current: Lexer = skip_whitespace_and_comments(lex)
    if is_at_end(current) {
        return Ok((current, TokEOF))
    }
    let c: char = current_char(current)

    if c == '(' { return Ok((advance(current), TokLParen)) }
    if c == ')' { return Ok((advance(current), TokRParen)) }
    if c == '\'' { return Ok((advance(current), TokQuote)) }
    if c == '"' { return read_string(current) }

    if c == '#' {
        let next: char = peek_char(current, 1)
        if next == 't' { return Ok((advance(advance(current)), TokBool(true))) }
        if next == 'f' { return Ok((advance(advance(current)), TokBool(false))) }
        return Err(("Invalid # literal", current.pos))
    }

    if looking_at_number(current) {
        let result: (Lexer, Token) = read_number(current)
        return Ok(result)
    }

    if is_symbol_start(c) {
        let result: (Lexer, Token) = read_symbol(current)
        return Ok(result)
    }

    return Err(("Unexpected character", current.pos))
}

effect fn tokenize(input: string) -> LexResult {
    var lex: Lexer = lexer_new(input)
    var tokens: List[Token] = Nil

    loop {
        match next_token(lex) {
            Ok((new_lex, token)) => {
                tokens = Cons(token, tokens)
                lex = new_lex
                match token {
                    TokEOF => { break }
                    _ => { }
                }
            }
            Err((msg, pos)) => { return LexErr(msg, pos) }
        }
    }
    return LexOk(std.list.reverse(tokens))
}

// ============================================================================
// Parser
// ============================================================================

fn parse_expr(tokens: List[Token]) -> ParseResult {
    match tokens {
        Nil => { return ParseErr("Unexpected end of input") }
        Cons(token, rest) => {
            match token {
                TokInt(n) => { return ParseOk(LispInt(n), rest) }
                TokFloat(n) => { return ParseOk(LispFloat(n), rest) }
                TokString(s) => { return ParseOk(LispString(s), rest) }
                TokSymbol(s) => { return ParseOk(LispSymbol(s), rest) }
                TokBool(b) => { return ParseOk(LispBool(b), rest) }
                TokLParen => { return parse_list(rest) }
                TokRParen => { return ParseErr("Unexpected )") }
                TokQuote => { return parse_quoted(rest) }
                TokEOF => { return ParseErr("Unexpected EOF") }
            }
        }
    }
}

fn parse_list(tokens: List[Token]) -> ParseResult {
    var current: List[Token] = tokens
    var elements: List[LispValue] = Nil

    loop {
        match current {
            Nil => { return ParseErr("Unclosed list") }
            Cons(token, rest) => {
                match token {
                    TokRParen => {
                        return ParseOk(LispList(std.list.reverse(elements)), rest)
                    }
                    TokEOF => { return ParseErr("Unclosed list at EOF") }
                    _ => {
                        match parse_expr(current) {
                            ParseOk(value, remaining) => {
                                elements = Cons(value, elements)
                                current = remaining
                            }
                            ParseErr(msg) => { return ParseErr(msg) }
                        }
                    }
                }
            }
        }
    }
}

fn parse_quoted(tokens: List[Token]) -> ParseResult {
    match parse_expr(tokens) {
        ParseOk(value, rest) => {
            let quote_sym: LispValue = LispSymbol("quote")
            let quoted: LispValue = LispList(Cons(quote_sym, Cons(value, Nil)))
            return ParseOk(quoted, rest)
        }
        ParseErr(msg) => { return ParseErr(msg) }
    }
}

fn parse_all(tokens: List[Token]) -> ParseAllResult {
    var current: List[Token] = tokens
    var exprs: List[LispValue] = Nil

    loop {
        match current {
            Nil => { return ParseAllOk(std.list.reverse(exprs)) }
            Cons(token, _) => {
                match token {
                    TokEOF => { return ParseAllOk(std.list.reverse(exprs)) }
                    _ => {
                        match parse_expr(current) {
                            ParseOk(value, remaining) => {
                                exprs = Cons(value, exprs)
                                current = remaining
                            }
                            ParseErr(msg) => { return ParseAllErr(msg) }
                        }
                    }
                }
            }
        }
    }
}

// ============================================================================
// Environment (using association list instead of HashMap for simplicity)
// ============================================================================

// Binding is a name-value pair
type Binding = (string, LispValue)

// Environment is a list of bindings plus optional parent
type EnvData = {
    bindings: List[Binding],
    parent: Option[Env]
}

fn env_new() -> Env {
    return Env { bindings: std.map.new(), parent: None }
}

fn env_extend(parent: Env) -> Env {
    return Env { bindings: std.map.new(), parent: Some(parent) }
}

// Helper to lookup in a binding list
fn lookup_in_bindings(bindings: List[Binding], name: string) -> Option[LispValue] {
    match bindings {
        Nil => { return None }
        Cons(binding, rest) => {
            let (bname, bvalue): (string, LispValue) = binding
            if bname == name {
                return Some(bvalue)
            }
            return lookup_in_bindings(rest, name)
        }
    }
}

fn env_define(env: Env, name: string, value: LispValue) -> Env {
    let new_bindings: HashMap = std.map.put(env.bindings, name, value)
    return Env { bindings: new_bindings, parent: env.parent }
}

fn env_lookup(env: Env, name: string) -> Option[LispValue] {
    match std.map.get(env.bindings, name) {
        Some(value) => {
            // Cast from any to LispValue
            return Some(value)
        }
        None => {
            match env.parent {
                Some(parent) => { return env_lookup(parent, name) }
                None => { return None }
            }
        }
    }
}

fn env_set(env: Env, name: string, value: LispValue) -> Result[Env, string] {
    if std.map.contains(env.bindings, name) {
        let new_bindings: HashMap = std.map.put(env.bindings, name, value)
        return Ok(Env { bindings: new_bindings, parent: env.parent })
    } else {
        match env.parent {
            Some(parent) => {
                match env_set(parent, name, value) {
                    Ok(new_parent) => {
                        return Ok(Env { bindings: env.bindings, parent: Some(new_parent) })
                    }
                    Err(msg) => { return Err(msg) }
                }
            }
            None => { return Err("Undefined variable: " + name) }
        }
    }
}

fn env_define_all(env: Env, names: List[string], values: List[LispValue]) -> Result[Env, string] {
    var current_env: Env = env
    var name_list: List[string] = names
    var value_list: List[LispValue] = values

    loop {
        match (name_list, value_list) {
            (Nil, Nil) => { return Ok(current_env) }
            (Cons(name, rest_names), Cons(value, rest_values)) => {
                current_env = env_define(current_env, name, value)
                name_list = rest_names
                value_list = rest_values
            }
            (Nil, Cons(_, _)) => { return Err("Too many arguments") }
            (Cons(_, _), Nil) => { return Err("Not enough arguments") }
        }
    }
}

// ============================================================================
// Evaluator
// ============================================================================

fn lisp_to_string(v: LispValue) -> string {
    match v {
        LispNil => { return "()" }
        LispBool(b) => { if b { return "#t" } else { return "#f" } }
        LispInt(n) => { return to_string(n) }
        LispFloat(n) => { return to_string(n) }
        LispString(s) => { return "\"" + s + "\"" }
        LispSymbol(s) => { return s }
        LispList(items) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "(")
            var first: bool = true
            for item in items {
                if not first { sb = std.builder.append(sb, " ") }
                sb = std.builder.append(sb, lisp_to_string(item))
                first = false
            }
            sb = std.builder.append(sb, ")")
            return std.builder.build(sb)
        }
        LispLambda(params, _, _) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "#<lambda (")
            var first: bool = true
            for p in params {
                if not first { sb = std.builder.append(sb, " ") }
                sb = std.builder.append(sb, p)
                first = false
            }
            sb = std.builder.append(sb, ")>")
            return std.builder.build(sb)
        }
        LispBuiltin(name) => { return "#<builtin:" + name + ">" }
    }
}

fn is_truthy(v: LispValue) -> bool {
    match v { LispBool(b) => { return b } _ => { return true } }
}

effect fn eval(expr: LispValue, env: Env) -> EvalResult {
    match expr {
        LispNil => { return EvalOk(LispNil, env) }
        LispBool(b) => { return EvalOk(LispBool(b), env) }
        LispInt(n) => { return EvalOk(LispInt(n), env) }
        LispFloat(n) => { return EvalOk(LispFloat(n), env) }
        LispString(s) => { return EvalOk(LispString(s), env) }
        LispSymbol(name) => {
            match env_lookup(env, name) {
                Some(value) => { return EvalOk(value, env) }
                None => { return EvalErr("Undefined variable: " + name) }
            }
        }
        LispList(items) => {
            match items {
                Nil => { return EvalOk(LispNil, env) }
                Cons(first, rest) => { return eval_list(first, rest, env) }
            }
        }
        LispLambda(p, b, e) => { return EvalOk(LispLambda(p, b, e), env) }
        LispBuiltin(n) => { return EvalOk(LispBuiltin(n), env) }
    }
}

effect fn eval_list(first: LispValue, rest: List[LispValue], env: Env) -> EvalResult {
    match first {
        LispSymbol(name) => {
            if name == "quote" { return eval_quote(rest, env) }
            if name == "if" { return eval_if(rest, env) }
            if name == "define" { return eval_define(rest, env) }
            if name == "lambda" { return eval_lambda(rest, env) }
            if name == "let" { return eval_let(rest, env) }
            if name == "begin" { return eval_begin(rest, env) }
            if name == "set!" { return eval_set(rest, env) }
            if name == "and" { return eval_and(rest, env) }
            if name == "or" { return eval_or(rest, env) }
            return eval_application(first, rest, env)
        }
        _ => { return eval_application(first, rest, env) }
    }
}

fn eval_quote(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(value, Nil) => { return EvalOk(value, env) }
        _ => { return EvalErr("quote requires one argument") }
    }
}

fn eval_if(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(cond, Cons(then_expr, else_part)) => {
            match eval(cond, env) {
                EvalOk(cond_val, env2) => {
                    if is_truthy(cond_val) {
                        return eval(then_expr, env2)
                    } else {
                        match else_part {
                            Cons(else_expr, Nil) => { return eval(else_expr, env2) }
                            Nil => { return EvalOk(LispNil, env2) }
                            _ => { return EvalErr("if: too many arguments") }
                        }
                    }
                }
                EvalErr(msg) => { return EvalErr(msg) }
            }
        }
        _ => { return EvalErr("if requires 2-3 arguments") }
    }
}

fn eval_define(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(name), Cons(value_expr, Nil)) => {
            match eval(value_expr, env) {
                EvalOk(value, env2) => {
                    let new_env: Env = env_define(env2, name, value)
                    return EvalOk(LispNil, new_env)
                }
                EvalErr(msg) => { return EvalErr(msg) }
            }
        }
        Cons(LispList(name_and_params), body) => {
            match name_and_params {
                Cons(LispSymbol(name), params) => {
                    match extract_param_names(params) {
                        Ok(param_names) => {
                            let lambda_body: LispValue = make_begin(body)
                            let lambda: LispValue = LispLambda(param_names, lambda_body, env)
                            let new_env: Env = env_define(env, name, lambda)
                            return EvalOk(LispNil, new_env)
                        }
                        Err(msg) => { return EvalErr(msg) }
                    }
                }
                _ => { return EvalErr("define: invalid function definition") }
            }
        }
        _ => { return EvalErr("define: invalid syntax") }
    }
}

fn extract_param_names(params: List[LispValue]) -> Result[List[string], string] {
    var names: List[string] = Nil
    for p in params {
        match p {
            LispSymbol(name) => { names = Cons(name, names) }
            _ => { return Err("Parameter must be a symbol") }
        }
    }
    return Ok(std.list.reverse(names))
}

fn make_begin(body: List[LispValue]) -> LispValue {
    match body {
        Cons(single, Nil) => { return single }
        _ => { return LispList(Cons(LispSymbol("begin"), body)) }
    }
}

fn eval_lambda(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(params), body) => {
            match extract_param_names(params) {
                Ok(param_names) => {
                    let lambda_body: LispValue = make_begin(body)
                    return EvalOk(LispLambda(param_names, lambda_body, env), env)
                }
                Err(msg) => { return EvalErr(msg) }
            }
        }
        _ => { return EvalErr("lambda: invalid syntax") }
    }
}

fn eval_let(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(bindings), body) => {
            var let_env: Env = env_extend(env)
            for binding in bindings {
                match binding {
                    LispList(Cons(LispSymbol(name), Cons(value_expr, Nil))) => {
                        match eval(value_expr, env) {
                            EvalOk(value, _) => { let_env = env_define(let_env, name, value) }
                            EvalErr(msg) => { return EvalErr(msg) }
                        }
                    }
                    _ => { return EvalErr("let: invalid binding") }
                }
            }
            return eval_begin_list(body, let_env)
        }
        _ => { return EvalErr("let: invalid syntax") }
    }
}

fn eval_begin(args: List[LispValue], env: Env) -> EvalResult {
    return eval_begin_list(args, env)
}

fn eval_begin_list(exprs: List[LispValue], env: Env) -> EvalResult {
    var current_env: Env = env
    var result: LispValue = LispNil
    for expr in exprs {
        match eval(expr, current_env) {
            EvalOk(value, new_env) => {
                result = value
                current_env = new_env
            }
            EvalErr(msg) => { return EvalErr(msg) }
        }
    }
    return EvalOk(result, current_env)
}

fn eval_set(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(name), Cons(value_expr, Nil)) => {
            match eval(value_expr, env) {
                EvalOk(value, env2) => {
                    match env_set(env2, name, value) {
                        Ok(new_env) => { return EvalOk(LispNil, new_env) }
                        Err(msg) => { return EvalErr(msg) }
                    }
                }
                EvalErr(msg) => { return EvalErr(msg) }
            }
        }
        _ => { return EvalErr("set! requires variable and value") }
    }
}

fn eval_and(args: List[LispValue], env: Env) -> EvalResult {
    var current_env: Env = env
    var result: LispValue = LispBool(true)
    for arg in args {
        match eval(arg, current_env) {
            EvalOk(value, new_env) => {
                current_env = new_env
                if not is_truthy(value) { return EvalOk(LispBool(false), current_env) }
                result = value
            }
            EvalErr(msg) => { return EvalErr(msg) }
        }
    }
    return EvalOk(result, current_env)
}

fn eval_or(args: List[LispValue], env: Env) -> EvalResult {
    var current_env: Env = env
    for arg in args {
        match eval(arg, current_env) {
            EvalOk(value, new_env) => {
                current_env = new_env
                if is_truthy(value) { return EvalOk(value, current_env) }
            }
            EvalErr(msg) => { return EvalErr(msg) }
        }
    }
    return EvalOk(LispBool(false), current_env)
}

effect fn eval_application(op_expr: LispValue, args: List[LispValue], env: Env) -> EvalResult {
    match eval(op_expr, env) {
        EvalOk(op, env2) => {
            match eval_list_values(args, env2) {
                Ok((arg_values, env3)) => { return apply(op, arg_values, env3) }
                Err(msg) => { return EvalErr(msg) }
            }
        }
        EvalErr(msg) => { return EvalErr(msg) }
    }
}

effect fn eval_list_values(exprs: List[LispValue], env: Env) -> Result[(List[LispValue], Env), string] {
    var current_env: Env = env
    var values: List[LispValue] = Nil
    for expr in exprs {
        match eval(expr, current_env) {
            EvalOk(value, new_env) => {
                values = Cons(value, values)
                current_env = new_env
            }
            EvalErr(msg) => { return Err(msg) }
        }
    }
    return Ok((std.list.reverse(values), current_env))
}

effect fn apply(func: LispValue, args: List[LispValue], env: Env) -> EvalResult {
    match func {
        LispLambda(params, body, closure_env) => {
            // Create call environment by extending closure_env with the caller's env as fallback
            // This allows recursive functions to find themselves in the caller's environment
            // First merge: closure_env for lexical scope, env for dynamic lookups (like self-reference)
            let base_env: Env = Env {
                bindings: closure_env.bindings,
                parent: Some(env)
            }
            let call_env: Env = env_extend(base_env)
            match env_define_all(call_env, params, args) {
                Ok(bound_env) => {
                    match eval(body, bound_env) {
                        EvalOk(result, _) => { return EvalOk(result, env) }
                        EvalErr(msg) => { return EvalErr(msg) }
                    }
                }
                Err(msg) => { return EvalErr(msg) }
            }
        }
        LispBuiltin(name) => { return apply_builtin(name, args, env) }
        _ => { return EvalErr("Cannot apply: " + lisp_to_string(func)) }
    }
}

// ============================================================================
// Built-in Functions
// ============================================================================

effect fn apply_builtin(name: string, args: List[LispValue], env: Env) -> EvalResult {
    if name == "+" { return builtin_add(args, env) }
    if name == "-" { return builtin_sub(args, env) }
    if name == "*" { return builtin_mul(args, env) }
    if name == "/" { return builtin_div(args, env) }
    if name == "mod" { return builtin_mod(args, env) }
    if name == "=" { return builtin_num_eq(args, env) }
    if name == "<" { return builtin_lt(args, env) }
    if name == ">" { return builtin_gt(args, env) }
    if name == "<=" { return builtin_le(args, env) }
    if name == ">=" { return builtin_ge(args, env) }
    if name == "cons" { return builtin_cons(args, env) }
    if name == "car" { return builtin_car(args, env) }
    if name == "cdr" { return builtin_cdr(args, env) }
    if name == "list" { return EvalOk(LispList(args), env) }
    if name == "null?" { return builtin_null(args, env) }
    if name == "pair?" { return builtin_pair(args, env) }
    if name == "length" { return builtin_length(args, env) }
    if name == "number?" { return builtin_numberp(args, env) }
    if name == "string?" { return builtin_stringp(args, env) }
    if name == "symbol?" { return builtin_symbolp(args, env) }
    if name == "procedure?" { return builtin_procedurep(args, env) }
    if name == "boolean?" { return builtin_booleanp(args, env) }
    if name == "eq?" { return builtin_eqp(args, env) }
    if name == "equal?" { return builtin_equalp(args, env) }
    if name == "not" { return builtin_not(args, env) }
    if name == "string-append" { return builtin_string_append(args, env) }
    if name == "string-length" { return builtin_string_length(args, env) }
    if name == "number->string" { return builtin_num_to_str(args, env) }
    if name == "string->number" { return builtin_str_to_num(args, env) }
    if name == "abs" { return builtin_abs(args, env) }
    if name == "min" { return builtin_min(args, env) }
    if name == "max" { return builtin_max(args, env) }
    if name == "display" { return builtin_display(args, env) }
    if name == "newline" { return builtin_newline(args, env) }
    return EvalErr("Unknown builtin: " + name)
}

effect fn builtin_display(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(v, Nil) => {
            match v {
                LispString(s) => { std.io.print(s) }
                _ => { std.io.print(lisp_to_string(v)) }
            }
            return EvalOk(LispNil, env)
        }
        _ => { return EvalErr("display: requires one argument") }
    }
}

effect fn builtin_newline(args: List[LispValue], env: Env) -> EvalResult {
    std.io.println("")
    return EvalOk(LispNil, env)
}

fn builtin_add(args: List[LispValue], env: Env) -> EvalResult {
    var sum_int: i64 = 0i64
    var sum_float: f64 = 0.0
    var is_float: bool = false
    for arg in args {
        match arg {
            LispInt(n) => { if is_float { sum_float = sum_float + to_float(n) } else { sum_int = sum_int + n } }
            LispFloat(n) => {
                if not is_float {
                    is_float = true
                    sum_float = to_float(sum_int)
                }
                sum_float = sum_float + n
            }
            _ => { return EvalErr("+: expected number") }
        }
    }
    if is_float { return EvalOk(LispFloat(sum_float), env) } else { return EvalOk(LispInt(sum_int), env) }
}

fn builtin_sub(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Nil => { return EvalErr("-: requires arguments") }
        Cons(first, rest) => {
            match first {
                LispInt(n) => {
                    match rest {
                        Nil => { return EvalOk(LispInt(0i64 - n), env) }
                        _ => {
                            var result: i64 = n
                            for arg in rest {
                                match arg {
                                    LispInt(m) => { result = result - m }
                                    _ => { return EvalErr("-: expected number") }
                                }
                            }
                            return EvalOk(LispInt(result), env)
                        }
                    }
                }
                LispFloat(n) => {
                    match rest {
                        Nil => { return EvalOk(LispFloat(0.0 - n), env) }
                        _ => {
                            var result: f64 = n
                            for arg in rest {
                                match arg {
                                    LispFloat(m) => { result = result - m }
                                    LispInt(m) => { result = result - to_float(m) }
                                    _ => { return EvalErr("-: expected number") }
                                }
                            }
                            return EvalOk(LispFloat(result), env)
                        }
                    }
                }
                _ => { return EvalErr("-: expected number") }
            }
        }
    }
}

fn builtin_mul(args: List[LispValue], env: Env) -> EvalResult {
    var prod_int: i64 = 1i64
    var prod_float: f64 = 1.0
    var is_float: bool = false
    for arg in args {
        match arg {
            LispInt(n) => { if is_float { prod_float = prod_float * to_float(n) } else { prod_int = prod_int * n } }
            LispFloat(n) => {
                if not is_float {
                    is_float = true
                    prod_float = to_float(prod_int)
                }
                prod_float = prod_float * n
            }
            _ => { return EvalErr("*: expected number") }
        }
    }
    if is_float { return EvalOk(LispFloat(prod_float), env) } else { return EvalOk(LispInt(prod_int), env) }
}

fn builtin_div(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return EvalErr("/: division by zero") }
            return EvalOk(LispInt(a / b), env)
        }
        _ => { return EvalErr("/: requires two integer arguments") }
    }
}

fn builtin_mod(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return EvalErr("mod: division by zero") }
            return EvalOk(LispInt(a % b), env)
        }
        _ => { return EvalErr("mod: requires two integers") }
    }
}

fn builtin_num_eq(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a == b), env) }
        Cons(LispFloat(a), Cons(LispFloat(b), Nil)) => { return EvalOk(LispBool(a == b), env) }
        _ => { return EvalErr("=: requires two numbers") }
    }
}

fn builtin_lt(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a < b), env) }
        _ => { return EvalErr("<: requires two numbers") }
    }
}

fn builtin_gt(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a > b), env) }
        _ => { return EvalErr(">: requires two numbers") }
    }
}

fn builtin_le(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a <= b), env) }
        _ => { return EvalErr("<=: requires two numbers") }
    }
}

fn builtin_ge(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a >= b), env) }
        _ => { return EvalErr(">=: requires two numbers") }
    }
}

fn builtin_cons(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(head, Cons(LispList(tail), Nil)) => { return EvalOk(LispList(Cons(head, tail)), env) }
        Cons(head, Cons(LispNil, Nil)) => { return EvalOk(LispList(Cons(head, Nil)), env) }
        _ => { return EvalErr("cons: requires element and list") }
    }
}

fn builtin_car(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Cons(head, _)), Nil) => { return EvalOk(head, env) }
        _ => { return EvalErr("car: requires non-empty list") }
    }
}

fn builtin_cdr(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Cons(_, tail)), Nil) => { return EvalOk(LispList(tail), env) }
        _ => { return EvalErr("cdr: requires non-empty list") }
    }
}

fn builtin_null(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Nil), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(LispNil, Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("null?: requires one argument") }
    }
}

fn builtin_pair(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Cons(_, _)), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("pair?: requires one argument") }
    }
}

fn builtin_length(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispList(items), Nil) => { return EvalOk(LispInt(std.list.length(items)), env) }
        Cons(LispNil, Nil) => { return EvalOk(LispInt(0i64), env) }
        _ => { return EvalErr("length: requires a list") }
    }
}

fn builtin_numberp(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(LispFloat(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("number?: requires one argument") }
    }
}

fn builtin_stringp(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispString(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("string?: requires one argument") }
    }
}

fn builtin_symbolp(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("symbol?: requires one argument") }
    }
}

fn builtin_procedurep(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispLambda(_, _, _), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(LispBuiltin(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("procedure?: requires one argument") }
    }
}

fn builtin_booleanp(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispBool(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("boolean?: requires one argument") }
    }
}

fn values_eq(a: LispValue, b: LispValue) -> bool {
    match (a, b) {
        (LispNil, LispNil) => { return true }
        (LispBool(x), LispBool(y)) => { return x == y }
        (LispInt(x), LispInt(y)) => { return x == y }
        (LispSymbol(x), LispSymbol(y)) => { return x == y }
        (LispString(x), LispString(y)) => { return x == y }
        _ => { return false }
    }
}

fn builtin_eqp(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(a, Cons(b, Nil)) => { return EvalOk(LispBool(values_eq(a, b)), env) }
        _ => { return EvalErr("eq?: requires two arguments") }
    }
}

fn values_equal(a: LispValue, b: LispValue) -> bool {
    match (a, b) {
        (LispNil, LispNil) => { return true }
        (LispBool(x), LispBool(y)) => { return x == y }
        (LispInt(x), LispInt(y)) => { return x == y }
        (LispFloat(x), LispFloat(y)) => { return x == y }
        (LispSymbol(x), LispSymbol(y)) => { return x == y }
        (LispString(x), LispString(y)) => { return x == y }
        (LispList(xs), LispList(ys)) => { return lists_equal(xs, ys) }
        _ => { return false }
    }
}

fn lists_equal(xs: List[LispValue], ys: List[LispValue]) -> bool {
    match (xs, ys) {
        (Nil, Nil) => { return true }
        (Cons(x, xr), Cons(y, yr)) => {
            if not values_equal(x, y) {
                return false
            }
            return lists_equal(xr, yr)
        }
        _ => { return false }
    }
}

fn builtin_equalp(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(a, Cons(b, Nil)) => { return EvalOk(LispBool(values_equal(a, b)), env) }
        _ => { return EvalErr("equal?: requires two arguments") }
    }
}

fn builtin_not(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(v, Nil) => { return EvalOk(LispBool(not is_truthy(v)), env) }
        _ => { return EvalErr("not: requires one argument") }
    }
}

fn builtin_string_append(args: List[LispValue], env: Env) -> EvalResult {
    var sb: StringBuilder = std.builder.new()
    for arg in args {
        match arg {
            LispString(s) => { sb = std.builder.append(sb, s) }
            _ => { return EvalErr("string-append: requires strings") }
        }
    }
    return EvalOk(LispString(std.builder.build(sb)), env)
}

fn builtin_string_length(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Nil) => { return EvalOk(LispInt(std.string.length(s)), env) }
        _ => { return EvalErr("string-length: requires one string") }
    }
}

fn builtin_num_to_str(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(n), Nil) => { return EvalOk(LispString(to_string(n)), env) }
        Cons(LispFloat(n), Nil) => { return EvalOk(LispString(to_string(n)), env) }
        _ => { return EvalErr("number->string: requires a number") }
    }
}

fn builtin_str_to_num(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Nil) => {
            match std.string.parse_int(s) {
                Some(n) => { return EvalOk(LispInt(n), env) }
                None => {
                    match std.string.parse_float(s) {
                        Some(f) => { return EvalOk(LispFloat(f), env) }
                        None => { return EvalOk(LispBool(false), env) }
                    }
                }
            }
        }
        _ => { return EvalErr("string->number: requires a string") }
    }
}

fn builtin_abs(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(n), Nil) => { if n < 0i64 { return EvalOk(LispInt(0i64 - n), env) } else { return EvalOk(LispInt(n), env) } }
        Cons(LispFloat(n), Nil) => { if n < 0.0 { return EvalOk(LispFloat(0.0 - n), env) } else { return EvalOk(LispFloat(n), env) } }
        _ => { return EvalErr("abs: requires a number") }
    }
}

fn builtin_min(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a < b { return EvalOk(LispInt(a), env) } else { return EvalOk(LispInt(b), env) } }
        _ => { return EvalErr("min: requires two numbers") }
    }
}

fn builtin_max(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a > b { return EvalOk(LispInt(a), env) } else { return EvalOk(LispInt(b), env) } }
        _ => { return EvalErr("max: requires two numbers") }
    }
}

// ============================================================================
// Initial Environment
// ============================================================================

fn make_initial_env() -> Env {
    var env: Env = env_new()
    env = env_define(env, "+", LispBuiltin("+"))
    env = env_define(env, "-", LispBuiltin("-"))
    env = env_define(env, "*", LispBuiltin("*"))
    env = env_define(env, "/", LispBuiltin("/"))
    env = env_define(env, "mod", LispBuiltin("mod"))
    env = env_define(env, "=", LispBuiltin("="))
    env = env_define(env, "<", LispBuiltin("<"))
    env = env_define(env, ">", LispBuiltin(">"))
    env = env_define(env, "<=", LispBuiltin("<="))
    env = env_define(env, ">=", LispBuiltin(">="))
    env = env_define(env, "cons", LispBuiltin("cons"))
    env = env_define(env, "car", LispBuiltin("car"))
    env = env_define(env, "cdr", LispBuiltin("cdr"))
    env = env_define(env, "list", LispBuiltin("list"))
    env = env_define(env, "null?", LispBuiltin("null?"))
    env = env_define(env, "pair?", LispBuiltin("pair?"))
    env = env_define(env, "length", LispBuiltin("length"))
    env = env_define(env, "number?", LispBuiltin("number?"))
    env = env_define(env, "string?", LispBuiltin("string?"))
    env = env_define(env, "symbol?", LispBuiltin("symbol?"))
    env = env_define(env, "procedure?", LispBuiltin("procedure?"))
    env = env_define(env, "boolean?", LispBuiltin("boolean?"))
    env = env_define(env, "eq?", LispBuiltin("eq?"))
    env = env_define(env, "equal?", LispBuiltin("equal?"))
    env = env_define(env, "not", LispBuiltin("not"))
    env = env_define(env, "string-append", LispBuiltin("string-append"))
    env = env_define(env, "string-length", LispBuiltin("string-length"))
    env = env_define(env, "number->string", LispBuiltin("number->string"))
    env = env_define(env, "string->number", LispBuiltin("string->number"))
    env = env_define(env, "abs", LispBuiltin("abs"))
    env = env_define(env, "min", LispBuiltin("min"))
    env = env_define(env, "max", LispBuiltin("max"))
    env = env_define(env, "display", LispBuiltin("display"))
    env = env_define(env, "newline", LispBuiltin("newline"))
    return env
}

// ============================================================================
// Intermediate Representation (IR)
// ============================================================================

type IRExpr =
    | IRConst(LispValue)
    | IRVar(string)
    | IRIf(IRExpr, IRExpr, IRExpr)
    | IRLet(List[(string, IRExpr)], IRExpr)
    | IRLambda(List[string], IRExpr)
    | IRApp(IRExpr, List[IRExpr])
    | IRDefine(string, IRExpr)
    | IRBegin(List[IRExpr])
    | IRSet(string, IRExpr)
    | IRBuiltin(string, List[IRExpr])
    | IRQuote(LispValue)
    | IRAnd(List[IRExpr])
    | IROr(List[IRExpr])

type TransformResult =
    | TransformOk(IRExpr)
    | TransformErr(string)

type TransformListResult =
    | TransformListOk(List[IRExpr])
    | TransformListErr(string)

// ============================================================================
// AST to IR Transformation
// ============================================================================

// List of builtin function names
fn is_builtin_name(name: string) -> bool {
    return name == "+" or name == "-" or name == "*" or name == "/" or
           name == "mod" or name == "=" or name == "<" or name == ">" or
           name == "<=" or name == ">=" or name == "cons" or name == "car" or
           name == "cdr" or name == "list" or name == "null?" or name == "pair?" or
           name == "length" or name == "number?" or name == "string?" or
           name == "symbol?" or name == "procedure?" or name == "boolean?" or
           name == "eq?" or name == "equal?" or name == "not" or
           name == "string-append" or name == "string-length" or
           name == "number->string" or name == "string->number" or
           name == "abs" or name == "min" or name == "max" or
           name == "display" or name == "newline"
}

fn to_ir(expr: LispValue) -> TransformResult {
    match expr {
        LispNil => { return TransformOk(IRConst(LispNil)) }
        LispBool(b) => { return TransformOk(IRConst(LispBool(b))) }
        LispInt(n) => { return TransformOk(IRConst(LispInt(n))) }
        LispFloat(n) => { return TransformOk(IRConst(LispFloat(n))) }
        LispString(s) => { return TransformOk(IRConst(LispString(s))) }
        LispSymbol(name) => { return TransformOk(IRVar(name)) }
        LispList(items) => { return to_ir_list(items) }
        LispLambda(_, _, _) => { return TransformErr("Cannot transform runtime lambda to IR") }
        LispBuiltin(_) => { return TransformErr("Cannot transform builtin to IR") }
    }
}

fn to_ir_list(items: List[LispValue]) -> TransformResult {
    match items {
        Nil => { return TransformOk(IRConst(LispNil)) }
        Cons(first, rest) => {
            match first {
                LispSymbol(name) => {
                    if name == "quote" { return to_ir_quote(rest) }
                    if name == "if" { return to_ir_if(rest) }
                    if name == "define" { return to_ir_define(rest) }
                    if name == "lambda" { return to_ir_lambda(rest) }
                    if name == "let" { return to_ir_let(rest) }
                    if name == "begin" { return to_ir_begin(rest) }
                    if name == "set!" { return to_ir_set(rest) }
                    if name == "and" { return to_ir_and(rest) }
                    if name == "or" { return to_ir_or(rest) }
                    // Check if it's a builtin call
                    if is_builtin_name(name) {
                        return to_ir_builtin(name, rest)
                    }
                    // Regular function application
                    return to_ir_app(first, rest)
                }
                _ => { return to_ir_app(first, rest) }
            }
        }
    }
}

fn to_ir_quote(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(value, Nil) => { return TransformOk(IRQuote(value)) }
        _ => { return TransformErr("quote requires one argument") }
    }
}

fn to_ir_if(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(cond, Cons(then_expr, else_part)) => {
            match to_ir(cond) {
                TransformOk(ir_cond) => {
                    match to_ir(then_expr) {
                        TransformOk(ir_then) => {
                            match else_part {
                                Cons(else_expr, Nil) => {
                                    match to_ir(else_expr) {
                                        TransformOk(ir_else) => {
                                            return TransformOk(IRIf(ir_cond, ir_then, ir_else))
                                        }
                                        TransformErr(msg) => { return TransformErr(msg) }
                                    }
                                }
                                Nil => {
                                    return TransformOk(IRIf(ir_cond, ir_then, IRConst(LispNil)))
                                }
                                _ => { return TransformErr("if: too many arguments") }
                            }
                        }
                        TransformErr(msg) => { return TransformErr(msg) }
                    }
                }
                TransformErr(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("if requires 2-3 arguments") }
    }
}

fn to_ir_define(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispSymbol(name), Cons(value_expr, Nil)) => {
            match to_ir(value_expr) {
                TransformOk(ir_value) => { return TransformOk(IRDefine(name, ir_value)) }
                TransformErr(msg) => { return TransformErr(msg) }
            }
        }
        Cons(LispList(name_and_params), body) => {
            // (define (name params...) body...) => (define name (lambda (params...) body...))
            match name_and_params {
                Cons(LispSymbol(name), params) => {
                    match extract_param_names(params) {
                        Ok(param_names) => {
                            let lambda_body: LispValue = make_begin(body)
                            match to_ir(lambda_body) {
                                TransformOk(ir_body) => {
                                    return TransformOk(IRDefine(name, IRLambda(param_names, ir_body)))
                                }
                                TransformErr(msg) => { return TransformErr(msg) }
                            }
                        }
                        Err(msg) => { return TransformErr(msg) }
                    }
                }
                _ => { return TransformErr("define: invalid function definition") }
            }
        }
        _ => { return TransformErr("define: invalid syntax") }
    }
}

fn to_ir_lambda(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispList(params), body) => {
            match extract_param_names(params) {
                Ok(param_names) => {
                    let lambda_body: LispValue = make_begin(body)
                    match to_ir(lambda_body) {
                        TransformOk(ir_body) => { return TransformOk(IRLambda(param_names, ir_body)) }
                        TransformErr(msg) => { return TransformErr(msg) }
                    }
                }
                Err(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("lambda: invalid syntax") }
    }
}

fn to_ir_let(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispList(bindings), body) => {
            match to_ir_let_bindings(bindings) {
                TransformListOk(ir_bindings_flat) => {
                    let lambda_body: LispValue = make_begin(body)
                    match to_ir(lambda_body) {
                        TransformOk(ir_body) => {
                            // Reconstruct binding pairs from flat list
                            let binding_pairs: List[(string, IRExpr)] = reconstruct_bindings(bindings, ir_bindings_flat)
                            return TransformOk(IRLet(binding_pairs, ir_body))
                        }
                        TransformErr(msg) => { return TransformErr(msg) }
                    }
                }
                TransformListErr(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("let: invalid syntax") }
    }
}

fn to_ir_let_bindings(bindings: List[LispValue]) -> TransformListResult {
    var ir_exprs: List[IRExpr] = Nil
    for binding in bindings {
        match binding {
            LispList(Cons(LispSymbol(_), Cons(value_expr, Nil))) => {
                match to_ir(value_expr) {
                    TransformOk(ir_value) => { ir_exprs = Cons(ir_value, ir_exprs) }
                    TransformErr(msg) => { return TransformListErr(msg) }
                }
            }
            _ => { return TransformListErr("let: invalid binding") }
        }
    }
    return TransformListOk(std.list.reverse(ir_exprs))
}

fn reconstruct_bindings(bindings: List[LispValue], ir_exprs: List[IRExpr]) -> List[(string, IRExpr)] {
    var result: List[(string, IRExpr)] = Nil
    var bind_iter: List[LispValue] = bindings
    var ir_iter: List[IRExpr] = ir_exprs
    loop {
        match (bind_iter, ir_iter) {
            (Cons(LispList(Cons(LispSymbol(name), _)), rest_binds), Cons(ir_val, rest_irs)) => {
                result = Cons((name, ir_val), result)
                bind_iter = rest_binds
                ir_iter = rest_irs
            }
            _ => { break }
        }
    }
    return std.list.reverse(result)
}

fn to_ir_begin(args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_exprs) => { return TransformOk(IRBegin(ir_exprs)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_set(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispSymbol(name), Cons(value_expr, Nil)) => {
            match to_ir(value_expr) {
                TransformOk(ir_value) => { return TransformOk(IRSet(name, ir_value)) }
                TransformErr(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("set! requires variable and value") }
    }
}

fn to_ir_and(args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_exprs) => { return TransformOk(IRAnd(ir_exprs)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_or(args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_exprs) => { return TransformOk(IROr(ir_exprs)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_builtin(name: string, args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_args) => { return TransformOk(IRBuiltin(name, ir_args)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_app(func: LispValue, args: List[LispValue]) -> TransformResult {
    match to_ir(func) {
        TransformOk(ir_func) => {
            match to_ir_list_exprs(args) {
                TransformListOk(ir_args) => { return TransformOk(IRApp(ir_func, ir_args)) }
                TransformListErr(msg) => { return TransformErr(msg) }
            }
        }
        TransformErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_list_exprs(exprs: List[LispValue]) -> TransformListResult {
    var result: List[IRExpr] = Nil
    for expr in exprs {
        match to_ir(expr) {
            TransformOk(ir_expr) => { result = Cons(ir_expr, result) }
            TransformErr(msg) => { return TransformListErr(msg) }
        }
    }
    return TransformListOk(std.list.reverse(result))
}

fn to_ir_program(exprs: List[LispValue]) -> TransformListResult {
    return to_ir_list_exprs(exprs)
}

// ============================================================================
// Code Generator (IR -> Kira Source)
// ============================================================================

// Counter for generating unique variable names
type CodegenState = { counter: i64 }

fn codegen_fresh_var(state: CodegenState) -> (CodegenState, string) {
    let new_state: CodegenState = CodegenState { counter: state.counter + 1i64 }
    return (new_state, "_v" + to_string(state.counter))
}

fn escape_string(s: string) -> string {
    var sb: StringBuilder = std.builder.new()
    let len: i32 = std.string.length(s)
    var i: i32 = 0
    while i < len {
        let c: char = char_at(s, i)
        if c == '\n' {
            sb = std.builder.append(sb, "\\n")
        } else if c == '\t' {
            sb = std.builder.append(sb, "\\t")
        } else if c == '\r' {
            sb = std.builder.append(sb, "\\r")
        } else if c == '\\' {
            sb = std.builder.append(sb, "\\\\")
        } else if c == '"' {
            sb = std.builder.append(sb, "\\\"")
        } else {
            sb = std.builder.append_char(sb, c)
        }
        i = i + 1
    }
    return std.builder.build(sb)
}

// Convert a Kira identifier to a valid Kira identifier
fn mangle_name(name: string) -> string {
    var sb: StringBuilder = std.builder.new()
    let len: i32 = std.string.length(name)
    var i: i32 = 0
    while i < len {
        let c: char = char_at(name, i)
        if c == '-' {
            sb = std.builder.append(sb, "_")
        } else if c == '?' {
            sb = std.builder.append(sb, "_p")
        } else if c == '!' {
            sb = std.builder.append(sb, "_bang")
        } else if c == '+' {
            sb = std.builder.append(sb, "_plus")
        } else if c == '*' {
            sb = std.builder.append(sb, "_star")
        } else if c == '/' {
            sb = std.builder.append(sb, "_slash")
        } else if c == '<' {
            sb = std.builder.append(sb, "_lt")
        } else if c == '>' {
            sb = std.builder.append(sb, "_gt")
        } else if c == '=' {
            sb = std.builder.append(sb, "_eq")
        } else if c == '>' {
            sb = std.builder.append(sb, "_gt")
        } else {
            sb = std.builder.append_char(sb, c)
        }
        i = i + 1
    }
    return std.builder.build(sb)
}

fn codegen_lisp_value(v: LispValue) -> string {
    match v {
        LispNil => { return "LispNil" }
        LispBool(b) => {
            if b { return "LispBool(true)" } else { return "LispBool(false)" }
        }
        LispInt(n) => { return "LispInt(" + to_string(n) + "i64)" }
        LispFloat(n) => { return "LispFloat(" + to_string(n) + ")" }
        LispString(s) => { return "LispString(\"" + escape_string(s) + "\")" }
        LispSymbol(s) => { return "LispSymbol(\"" + escape_string(s) + "\")" }
        LispList(items) => {
            return "LispList(" + codegen_list_items(items) + ")"
        }
        LispLambda(_, _, _) => { return "LispNil" }  // Can't serialize closures
        LispBuiltin(n) => { return "LispBuiltin(\"" + n + "\")" }
    }
}

fn codegen_list_items(items: List[LispValue]) -> string {
    match items {
        Nil => { return "Nil" }
        Cons(head, tail) => {
            return "Cons(" + codegen_lisp_value(head) + ", " + codegen_list_items(tail) + ")"
        }
    }
}

fn codegen_expr(ir: IRExpr) -> string {
    match ir {
        IRConst(v) => { return codegen_lisp_value(v) }
        IRVar(name) => { return mangle_name(name) }
        IRQuote(v) => { return codegen_lisp_value(v) }
        IRIf(cond, then_expr, else_expr) => {
            return "if is_truthy(" + codegen_expr(cond) + ") { " +
                   codegen_expr(then_expr) + " } else { " +
                   codegen_expr(else_expr) + " }"
        }
        IRLet(bindings, body) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "{ ")
            for binding in bindings {
                let (name, value): (string, IRExpr) = binding
                sb = std.builder.append(sb, "let ")
                sb = std.builder.append(sb, mangle_name(name))
                sb = std.builder.append(sb, ": LispValue = ")
                sb = std.builder.append(sb, codegen_expr(value))
                sb = std.builder.append(sb, "; ")
            }
            sb = std.builder.append(sb, codegen_expr(body))
            sb = std.builder.append(sb, " }")
            return std.builder.build(sb)
        }
        IRLambda(params, body) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "fn(")
            var first: bool = true
            for p in params {
                if not first { sb = std.builder.append(sb, ", ") }
                sb = std.builder.append(sb, mangle_name(p))
                sb = std.builder.append(sb, ": LispValue")
                first = false
            }
            sb = std.builder.append(sb, ") -> LispValue { ")
            sb = std.builder.append(sb, codegen_expr(body))
            sb = std.builder.append(sb, " }")
            return std.builder.build(sb)
        }
        IRApp(func, args) => {
            // If func is a variable reference, call it directly (since we compile functions to Kira fns)
            match func {
                IRVar(name) => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, mangle_name(name))
                    sb = std.builder.append(sb, "(")
                    var first: bool = true
                    for arg in args {
                        if not first { sb = std.builder.append(sb, ", ") }
                        sb = std.builder.append(sb, codegen_expr(arg))
                        first = false
                    }
                    sb = std.builder.append(sb, ")")
                    return std.builder.build(sb)
                }
                _ => {
                    // For lambda expressions or other complex callees, we'd need LispFunc
                    // For now, just generate a direct call (won't work for lambdas)
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, "/* complex callee */ (")
                    sb = std.builder.append(sb, codegen_expr(func))
                    sb = std.builder.append(sb, ")(")
                    var first: bool = true
                    for arg in args {
                        if not first { sb = std.builder.append(sb, ", ") }
                        sb = std.builder.append(sb, codegen_expr(arg))
                        first = false
                    }
                    sb = std.builder.append(sb, ")")
                    return std.builder.build(sb)
                }
            }
        }
        IRDefine(name, value) => {
            // Definitions are handled at top-level
            return "/* define " + name + " */"
        }
        IRBegin(exprs) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "{ ")
            var result_var: string = "_result"
            sb = std.builder.append(sb, "var ")
            sb = std.builder.append(sb, result_var)
            sb = std.builder.append(sb, ": LispValue = LispNil; ")
            for expr in exprs {
                sb = std.builder.append(sb, result_var)
                sb = std.builder.append(sb, " = ")
                sb = std.builder.append(sb, codegen_expr(expr))
                sb = std.builder.append(sb, "; ")
            }
            sb = std.builder.append(sb, result_var)
            sb = std.builder.append(sb, " }")
            return std.builder.build(sb)
        }
        IRSet(name, value) => {
            return "{ " + mangle_name(name) + " = " + codegen_expr(value) + "; LispNil }"
        }
        IRBuiltin(name, args) => {
            return codegen_builtin_call(name, args)
        }
        IRAnd(exprs) => {
            match exprs {
                Nil => { return "LispBool(true)" }
                Cons(single, Nil) => { return codegen_expr(single) }
                _ => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, "{ var _and_result: LispValue = LispBool(true); ")
                    for expr in exprs {
                        sb = std.builder.append(sb, "_and_result = ")
                        sb = std.builder.append(sb, codegen_expr(expr))
                        sb = std.builder.append(sb, "; if not is_truthy(_and_result) { _and_result } else { ")
                    }
                    sb = std.builder.append(sb, "_and_result")
                    for _ in exprs {
                        sb = std.builder.append(sb, " }")
                    }
                    sb = std.builder.append(sb, " }")
                    return std.builder.build(sb)
                }
            }
        }
        IROr(exprs) => {
            match exprs {
                Nil => { return "LispBool(false)" }
                Cons(single, Nil) => { return codegen_expr(single) }
                _ => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, "{ var _or_result: LispValue = LispBool(false); ")
                    for expr in exprs {
                        sb = std.builder.append(sb, "_or_result = ")
                        sb = std.builder.append(sb, codegen_expr(expr))
                        sb = std.builder.append(sb, "; if is_truthy(_or_result) { _or_result } else { ")
                    }
                    sb = std.builder.append(sb, "_or_result")
                    for _ in exprs {
                        sb = std.builder.append(sb, " }")
                    }
                    sb = std.builder.append(sb, " }")
                    return std.builder.build(sb)
                }
            }
        }
    }
}

fn codegen_args_list(args: List[IRExpr]) -> string {
    match args {
        Nil => { return "Nil" }
        Cons(arg, rest) => {
            return "Cons(" + codegen_expr(arg) + ", " + codegen_args_list(rest) + ")"
        }
    }
}

fn codegen_builtin_call(name: string, args: List[IRExpr]) -> string {
    // Generate inline code for builtins when possible
    if name == "+" {
        return "rt_add(" + codegen_args_list(args) + ")"
    }
    if name == "-" {
        return "rt_sub(" + codegen_args_list(args) + ")"
    }
    if name == "*" {
        return "rt_mul(" + codegen_args_list(args) + ")"
    }
    if name == "/" {
        return "rt_div(" + codegen_args_list(args) + ")"
    }
    if name == "mod" {
        return "rt_mod(" + codegen_args_list(args) + ")"
    }
    if name == "=" {
        return "rt_num_eq(" + codegen_args_list(args) + ")"
    }
    if name == "<" {
        return "rt_lt(" + codegen_args_list(args) + ")"
    }
    if name == ">" {
        return "rt_gt(" + codegen_args_list(args) + ")"
    }
    if name == "<=" {
        return "rt_le(" + codegen_args_list(args) + ")"
    }
    if name == ">=" {
        return "rt_ge(" + codegen_args_list(args) + ")"
    }
    if name == "cons" {
        return "rt_cons(" + codegen_args_list(args) + ")"
    }
    if name == "car" {
        return "rt_car(" + codegen_args_list(args) + ")"
    }
    if name == "cdr" {
        return "rt_cdr(" + codegen_args_list(args) + ")"
    }
    if name == "list" {
        return "LispList(" + codegen_args_list(args) + ")"
    }
    if name == "null?" {
        return "rt_null_p(" + codegen_args_list(args) + ")"
    }
    if name == "pair?" {
        return "rt_pair_p(" + codegen_args_list(args) + ")"
    }
    if name == "length" {
        return "rt_length(" + codegen_args_list(args) + ")"
    }
    if name == "not" {
        return "rt_not(" + codegen_args_list(args) + ")"
    }
    if name == "eq?" {
        return "rt_eq_p(" + codegen_args_list(args) + ")"
    }
    if name == "equal?" {
        return "rt_equal_p(" + codegen_args_list(args) + ")"
    }
    if name == "display" {
        return "rt_display(" + codegen_args_list(args) + ")"
    }
    if name == "newline" {
        return "rt_newline()"
    }
    if name == "number?" {
        return "rt_number_p(" + codegen_args_list(args) + ")"
    }
    if name == "string?" {
        return "rt_string_p(" + codegen_args_list(args) + ")"
    }
    if name == "symbol?" {
        return "rt_symbol_p(" + codegen_args_list(args) + ")"
    }
    if name == "procedure?" {
        return "rt_procedure_p(" + codegen_args_list(args) + ")"
    }
    if name == "boolean?" {
        return "rt_boolean_p(" + codegen_args_list(args) + ")"
    }
    if name == "string-append" {
        return "rt_string_append(" + codegen_args_list(args) + ")"
    }
    if name == "string-length" {
        return "rt_string_length(" + codegen_args_list(args) + ")"
    }
    if name == "number->string" {
        return "rt_number_to_string(" + codegen_args_list(args) + ")"
    }
    if name == "string->number" {
        return "rt_string_to_number(" + codegen_args_list(args) + ")"
    }
    if name == "abs" {
        return "rt_abs(" + codegen_args_list(args) + ")"
    }
    if name == "min" {
        return "rt_min(" + codegen_args_list(args) + ")"
    }
    if name == "max" {
        return "rt_max(" + codegen_args_list(args) + ")"
    }
    // Fallback: generic builtin call
    return "rt_call_builtin(\"" + name + "\", " + codegen_args_list(args) + ")"
}

// Collect top-level definitions
fn collect_definitions(ir_exprs: List[IRExpr]) -> (List[(string, IRExpr)], List[IRExpr]) {
    var defs: List[(string, IRExpr)] = Nil
    var others: List[IRExpr] = Nil
    for ir in ir_exprs {
        match ir {
            IRDefine(name, value) => { defs = Cons((name, value), defs) }
            _ => { others = Cons(ir, others) }
        }
    }
    return (std.list.reverse(defs), std.list.reverse(others))
}

// Generate the runtime library
fn generate_runtime() -> string {
    return "// Lisp Runtime Library (generated)

type LispValue =
    | LispNil
    | LispBool(bool)
    | LispInt(i64)
    | LispFloat(f64)
    | LispString(string)
    | LispSymbol(string)
    | LispList(List[LispValue])

fn is_truthy(v: LispValue) -> bool {
    match v { LispBool(b) => { return b } _ => { return true } }
}

fn lisp_to_string(v: LispValue) -> string {
    match v {
        LispNil => { return \"()\" }
        LispBool(b) => { if b { return \"#t\" } else { return \"#f\" } }
        LispInt(n) => { return to_string(n) }
        LispFloat(n) => { return to_string(n) }
        LispString(s) => { return \"\\\"\" + s + \"\\\"\" }
        LispSymbol(s) => { return s }
        LispList(items) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, \"(\")
            var first: bool = true
            for item in items {
                if not first { sb = std.builder.append(sb, \" \") }
                sb = std.builder.append(sb, lisp_to_string(item))
                first = false
            }
            sb = std.builder.append(sb, \")\")
            return std.builder.build(sb)
        }
    }
}

fn rt_add(args: List[LispValue]) -> LispValue {
    var sum: i64 = 0i64
    for arg in args {
        match arg {
            LispInt(n) => { sum = sum + n }
            _ => { return LispNil }
        }
    }
    return LispInt(sum)
}

fn rt_sub(args: List[LispValue]) -> LispValue {
    match args {
        Nil => { return LispNil }
        Cons(LispInt(first), rest) => {
            match rest {
                Nil => { return LispInt(0i64 - first) }
                _ => {
                    var result: i64 = first
                    for arg in rest {
                        match arg {
                            LispInt(n) => { result = result - n }
                            _ => { return LispNil }
                        }
                    }
                    return LispInt(result)
                }
            }
        }
        _ => { return LispNil }
    }
}

fn rt_mul(args: List[LispValue]) -> LispValue {
    var prod: i64 = 1i64
    for arg in args {
        match arg {
            LispInt(n) => { prod = prod * n }
            _ => { return LispNil }
        }
    }
    return LispInt(prod)
}

fn rt_div(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return LispNil }
            return LispInt(a / b)
        }
        _ => { return LispNil }
    }
}

fn rt_mod(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return LispNil }
            return LispInt(a % b)
        }
        _ => { return LispNil }
    }
}

fn rt_num_eq(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a == b) }
        _ => { return LispBool(false) }
    }
}

fn rt_lt(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a < b) }
        _ => { return LispBool(false) }
    }
}

fn rt_gt(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a > b) }
        _ => { return LispBool(false) }
    }
}

fn rt_le(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a <= b) }
        _ => { return LispBool(false) }
    }
}

fn rt_ge(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a >= b) }
        _ => { return LispBool(false) }
    }
}

fn rt_cons(args: List[LispValue]) -> LispValue {
    match args {
        Cons(head, Cons(LispList(tail), Nil)) => { return LispList(Cons(head, tail)) }
        Cons(head, Cons(LispNil, Nil)) => { return LispList(Cons(head, Nil)) }
        _ => { return LispNil }
    }
}

fn rt_car(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Cons(head, _)), Nil) => { return head }
        _ => { return LispNil }
    }
}

fn rt_cdr(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Cons(_, tail)), Nil) => { return LispList(tail) }
        _ => { return LispNil }
    }
}

fn rt_null_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Nil), Nil) => { return LispBool(true) }
        Cons(LispNil, Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_pair_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Cons(_, _)), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_length(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(items), Nil) => { return LispInt(std.list.length(items)) }
        Cons(LispNil, Nil) => { return LispInt(0i64) }
        _ => { return LispNil }
    }
}

fn rt_not(args: List[LispValue]) -> LispValue {
    match args {
        Cons(v, Nil) => { return LispBool(not is_truthy(v)) }
        _ => { return LispNil }
    }
}

fn rt_eq_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(a, Cons(b, Nil)) => {
            match (a, b) {
                (LispNil, LispNil) => { return LispBool(true) }
                (LispBool(x), LispBool(y)) => { return LispBool(x == y) }
                (LispInt(x), LispInt(y)) => { return LispBool(x == y) }
                (LispSymbol(x), LispSymbol(y)) => { return LispBool(x == y) }
                (LispString(x), LispString(y)) => { return LispBool(x == y) }
                _ => { return LispBool(false) }
            }
        }
        _ => { return LispBool(false) }
    }
}

fn lists_equal_rt(xs: List[LispValue], ys: List[LispValue]) -> bool {
    match (xs, ys) {
        (Nil, Nil) => { return true }
        (Cons(x, xr), Cons(y, yr)) => {
            if not values_equal_rt(x, y) { return false }
            return lists_equal_rt(xr, yr)
        }
        _ => { return false }
    }
}

fn values_equal_rt(a: LispValue, b: LispValue) -> bool {
    match (a, b) {
        (LispNil, LispNil) => { return true }
        (LispBool(x), LispBool(y)) => { return x == y }
        (LispInt(x), LispInt(y)) => { return x == y }
        (LispFloat(x), LispFloat(y)) => { return x == y }
        (LispSymbol(x), LispSymbol(y)) => { return x == y }
        (LispString(x), LispString(y)) => { return x == y }
        (LispList(xs), LispList(ys)) => { return lists_equal_rt(xs, ys) }
        _ => { return false }
    }
}

fn rt_equal_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(a, Cons(b, Nil)) => { return LispBool(values_equal_rt(a, b)) }
        _ => { return LispBool(false) }
    }
}

fn rt_number_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(_), Nil) => { return LispBool(true) }
        Cons(LispFloat(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_string_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispString(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_symbol_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispSymbol(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_procedure_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_boolean_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispBool(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_string_append(args: List[LispValue]) -> LispValue {
    var sb: StringBuilder = std.builder.new()
    for arg in args {
        match arg {
            LispString(s) => { sb = std.builder.append(sb, s) }
            _ => { return LispNil }
        }
    }
    return LispString(std.builder.build(sb))
}

fn rt_string_length(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispString(s), Nil) => { return LispInt(std.string.length(s)) }
        _ => { return LispNil }
    }
}

fn rt_number_to_string(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(n), Nil) => { return LispString(to_string(n)) }
        Cons(LispFloat(n), Nil) => { return LispString(to_string(n)) }
        _ => { return LispNil }
    }
}

fn rt_string_to_number(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispString(s), Nil) => {
            match std.string.parse_int(s) {
                Some(n) => { return LispInt(n) }
                None => {
                    match std.string.parse_float(s) {
                        Some(f) => { return LispFloat(f) }
                        None => { return LispBool(false) }
                    }
                }
            }
        }
        _ => { return LispNil }
    }
}

fn rt_abs(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(n), Nil) => { if n < 0i64 { return LispInt(0i64 - n) } else { return LispInt(n) } }
        Cons(LispFloat(n), Nil) => { if n < 0.0 { return LispFloat(0.0 - n) } else { return LispFloat(n) } }
        _ => { return LispNil }
    }
}

fn rt_min(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a < b { return LispInt(a) } else { return LispInt(b) } }
        _ => { return LispNil }
    }
}

fn rt_max(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a > b { return LispInt(a) } else { return LispInt(b) } }
        _ => { return LispNil }
    }
}

effect fn rt_display(args: List[LispValue]) -> LispValue {
    match args {
        Cons(v, Nil) => {
            match v {
                LispString(s) => { std.io.print(s) }
                _ => { std.io.print(lisp_to_string(v)) }
            }
            return LispNil
        }
        _ => { return LispNil }
    }
}

effect fn rt_newline() -> LispValue {
    std.io.println(\"\")
    return LispNil
}

"
}

// Generate compiled Kira program
fn generate_program(ir_exprs: List[IRExpr]) -> string {
    var sb: StringBuilder = std.builder.new()

    // Add runtime
    sb = std.builder.append(sb, generate_runtime())

    // Separate definitions from other expressions
    let (defs, others): (List[(string, IRExpr)], List[IRExpr]) = collect_definitions(ir_exprs)

    // Generate global definitions
    sb = std.builder.append(sb, "// User-defined functions\n")
    for def in defs {
        let (name, value): (string, IRExpr) = def
        match value {
            IRLambda(params, body) => {
                // Generate as a named function
                sb = std.builder.append(sb, "fn ")
                sb = std.builder.append(sb, mangle_name(name))
                sb = std.builder.append(sb, "(")
                var first: bool = true
                for p in params {
                    if not first { sb = std.builder.append(sb, ", ") }
                    sb = std.builder.append(sb, mangle_name(p))
                    sb = std.builder.append(sb, ": LispValue")
                    first = false
                }
                sb = std.builder.append(sb, ") -> LispValue {\n    return ")
                sb = std.builder.append(sb, codegen_expr(body))
                sb = std.builder.append(sb, "\n}\n\n")
            }
            _ => {
                // Generate as a global variable
                sb = std.builder.append(sb, "var ")
                sb = std.builder.append(sb, mangle_name(name))
                sb = std.builder.append(sb, ": LispValue = ")
                sb = std.builder.append(sb, codegen_expr(value))
                sb = std.builder.append(sb, "\n\n")
            }
        }
    }

    // Generate main function with top-level expressions
    sb = std.builder.append(sb, "effect fn main() -> void {\n")
    for expr in others {
        sb = std.builder.append(sb, "    let _: LispValue = ")
        sb = std.builder.append(sb, codegen_expr(expr))
        sb = std.builder.append(sb, "\n")
    }
    sb = std.builder.append(sb, "}\n")

    return std.builder.build(sb)
}

// ============================================================================
// Compiler Entry Point
// ============================================================================

effect fn compile_file(input_path: string, output_path: string) -> void {
    match std.fs.read_file(input_path) {
        Ok(source) => {
            match tokenize(source) {
                LexOk(tokens) => {
                    match parse_all(tokens) {
                        ParseAllOk(exprs) => {
                            match to_ir_program(exprs) {
                                TransformListOk(ir_exprs) => {
                                    let output: string = generate_program(ir_exprs)
                                    match std.fs.write_file(output_path, output) {
                                        Ok(_) => {
                                            std.io.println("Compiled " + input_path + " to " + output_path)
                                        }
                                        Err(msg) => {
                                            std.io.println("Error writing output: " + msg)
                                        }
                                    }
                                }
                                TransformListErr(msg) => {
                                    std.io.println("Transform error: " + msg)
                                }
                            }
                        }
                        ParseAllErr(msg) => {
                            std.io.println("Parse error: " + msg)
                        }
                    }
                }
                LexErr(msg, pos) => {
                    std.io.println("Lex error at " + to_string(pos) + ": " + msg)
                }
            }
        }
        Err(msg) => {
            std.io.println("Error reading file: " + msg)
        }
    }
}

// ============================================================================
// REPL and Main
// ============================================================================

effect fn run_program(source: string, env: Env) -> EvalResult {
    match tokenize(source) {
        LexOk(tokens) => {
            match parse_all(tokens) {
                ParseAllOk(exprs) => {
                    return eval_begin_list(exprs, env)
                }
                ParseAllErr(msg) => { return EvalErr("Parse error: " + msg) }
            }
        }
        LexErr(msg, pos) => { return EvalErr("Lex error at " + to_string(pos) + ": " + msg) }
    }
}

effect fn print_result(v: LispValue) -> void {
    let s: string = lisp_to_string(v)
    std.io.println(s)
}

effect fn repl_loop(env: Env) -> void {
    var current_env: Env = env
    loop {
        std.io.print("lisp> ")
        match std.io.read_line() {
            Ok(line) => {
                let trimmed: string = std.string.trim(line)
                if trimmed == "" {
                    // Empty line, continue
                } else if trimmed == "(exit)" or trimmed == "(quit)" {
                    std.io.println("Goodbye!")
                    break
                } else {
                    match tokenize(trimmed) {
                        LexOk(tokens) => {
                            match parse_all(tokens) {
                                ParseAllOk(exprs) => {
                                    match eval_begin_list(exprs, current_env) {
                                        EvalOk(result, new_env) => {
                                            print_result(result)
                                            current_env = new_env
                                        }
                                        EvalErr(msg) => {
                                            std.io.println("Error: " + msg)
                                        }
                                    }
                                }
                                ParseAllErr(msg) => {
                                    std.io.println("Parse error: " + msg)
                                }
                            }
                        }
                        LexErr(msg, pos) => {
                            std.io.println("Lex error at " + to_string(pos) + ": " + msg)
                        }
                    }
                }
            }
            Err(_) => {
                std.io.println("")
                break
            }
        }
    }
}

effect fn run_file(path: string) -> void {
    match std.fs.read_file(path) {
        Ok(content) => {
            let env: Env = make_initial_env()
            match run_program(content, env) {
                EvalOk(result, _) => {
                    print_result(result)
                }
                EvalErr(msg) => {
                    std.io.println("Error: " + msg)
                }
            }
        }
        Err(msg) => {
            std.io.println("Error reading file: " + msg)
        }
    }
}

fn replace_extension(path: string, new_ext: string) -> string {
    // Find the last '.' in the path
    let len: i32 = std.string.length(path)
    var dot_pos: i32 = -1
    var i: i32 = len - 1
    while i >= 0 {
        if char_at(path, i) == '.' {
            dot_pos = i
            break
        }
        if char_at(path, i) == '/' {
            break
        }
        i = i - 1
    }
    if dot_pos > 0 {
        return substr(path, 0, dot_pos) + new_ext
    } else {
        return path + new_ext
    }
}

fn print_usage() -> void {
    std.io.println("Usage: kira run src/main.ki [options]")
    std.io.println("")
    std.io.println("Options:")
    std.io.println("  (no args)           Start REPL")
    std.io.println("  run <file.lisp>     Run a Lisp file")
    std.io.println("  compile <file.lisp> Compile to Kira (output: <file>.ki)")
    std.io.println("  help                Show this help")
}

effect fn main() -> void {
    let args: List[string] = std.env.args()
    match args {
        Nil => {
            std.io.println("Kira Lisp Interpreter")
            std.io.println("Type (exit) or (quit) to exit")
            std.io.println("")
            let env: Env = make_initial_env()
            repl_loop(env)
        }
        Cons(cmd, cmd_args) => {
            if cmd == "help" {
                print_usage()
            } else if cmd == "run" {
                match cmd_args {
                    Cons(file, _) => { run_file(file) }
                    Nil => {
                        std.io.println("Error: run requires a file argument")
                        print_usage()
                    }
                }
            } else if cmd == "compile" {
                match cmd_args {
                    Cons(file, _) => {
                        let output: string = replace_extension(file, ".ki")
                        compile_file(file, output)
                    }
                    Nil => {
                        std.io.println("Error: compile requires a file argument")
                        print_usage()
                    }
                }
            } else {
                // Assume it's a file to run
                run_file(cmd)
            }
        }
    }
}
