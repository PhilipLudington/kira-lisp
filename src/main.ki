// Lisp Interpreter - Main Entry Point
// Combines lexer, parser, and evaluator into a working interpreter

// ============================================================================
// Token Types
// ============================================================================

type Token =
    | TokLParen
    | TokRParen
    | TokQuote
    | TokQuasiquote
    | TokUnquote
    | TokUnquoteSplicing
    | TokInt(i64)
    | TokFloat(f64)
    | TokString(string)
    | TokSymbol(string)
    | TokBool(bool)
    | TokEOF

// Source location tracking for error messages
type SourceLoc = {
    line: i32,
    column: i32,
    offset: i32,
    file: string
}

type LocatedToken = {
    token: Token,
    loc: SourceLoc
}

type LexResult =
    | LexOk(List[LocatedToken])
    | LexErr(string, SourceLoc)

// ============================================================================
// Lisp Value Types
// ============================================================================

type LispValue =
    | LispNil
    | LispBool(bool)
    | LispInt(i64)
    | LispFloat(f64)
    | LispString(string)
    | LispSymbol(string, Option[SourceLoc])
    | LispList(List[LispValue], Option[SourceLoc])
    | LispLambda(List[string], LispValue, Env)
    | LispRecursiveLambda(string, List[string], LispValue, Env)  // name, params, body, closure - for named recursive functions
    | LispBuiltin(string)
    | LispMacro(List[string], LispValue, Env)

type Env = {
    bindings: HashMap,
    parent: Option[Env]
}

type ParseResult =
    | ParseOk(LispValue, List[LocatedToken])
    | ParseErr(string, Option[SourceLoc])

type ParseAllResult =
    | ParseAllOk(List[LispValue])
    | ParseAllErr(string, Option[SourceLoc])

type EvalResult =
    | EvalOk(LispValue, Env)
    | EvalErr(string, Option[SourceLoc])
    | TailCall(LispValue, List[LispValue], Env)  // func, args, env - for TCO

// ============================================================================
// Lexer
// ============================================================================

type Lexer = {
    input: string,
    pos: i32,
    length: i32,
    line: i32,
    column: i32,
    file: string
}

// Helper to get substring (unwrap Option)
fn substr(s: string, start: i32, end: i32) -> string {
    match std.string.substring(s, start, end) {
        Some(result) => { return result }
        None => { return "" }
    }
}

// Helper to get char at index (unwrap Option)
fn char_at(s: string, idx: i32) -> char {
    match std.string.char_at(s, idx) {
        Some(c) => { return c }
        None => { return '\0' }
    }
}

fn lexer_new(input: string, file: string) -> Lexer {
    return Lexer {
        input: input,
        pos: 0,
        length: std.string.length(input),
        line: 1,
        column: 1,
        file: file
    }
}

fn lexer_loc(lex: Lexer) -> SourceLoc {
    return SourceLoc {
        line: lex.line,
        column: lex.column,
        offset: lex.pos,
        file: lex.file
    }
}

fn is_at_end(lex: Lexer) -> bool {
    return lex.pos >= lex.length
}

fn current_char(lex: Lexer) -> char {
    if is_at_end(lex) { return '\0' }
    return char_at(lex.input, lex.pos)
}

fn peek_char(lex: Lexer, offset: i32) -> char {
    let idx: i32 = lex.pos + offset
    if idx >= lex.length { return '\0' }
    return char_at(lex.input, idx)
}

fn advance(lex: Lexer) -> Lexer {
    let c: char = current_char(lex)
    if c == '\n' {
        return Lexer {
            input: lex.input,
            pos: lex.pos + 1,
            length: lex.length,
            line: lex.line + 1,
            column: 1,
            file: lex.file
        }
    } else {
        return Lexer {
            input: lex.input,
            pos: lex.pos + 1,
            length: lex.length,
            line: lex.line,
            column: lex.column + 1,
            file: lex.file
        }
    }
}

fn skip_whitespace_and_comments(lex: Lexer) -> Lexer {
    var current: Lexer = lex
    loop {
        if is_at_end(current) { break }
        let c: char = current_char(current)
        if c == ' ' or c == '\t' or c == '\n' or c == '\r' {
            current = advance(current)
        } else if c == ';' {
            while not is_at_end(current) and current_char(current) != '\n' {
                current = advance(current)
            }
        } else {
            break
        }
    }
    return current
}

fn is_digit(c: char) -> bool {
    return c >= '0' and c <= '9'
}

fn is_symbol_start(c: char) -> bool {
    return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or
           c == '+' or c == '-' or c == '*' or c == '/' or
           c == '<' or c == '>' or c == '=' or c == '!' or
           c == '?' or c == '_' or c == '&' or c == '%' or
           c == '^' or c == '~' or c == '@' or c == '$'
}

fn is_symbol_char(c: char) -> bool {
    return is_symbol_start(c) or is_digit(c) or c == '.' or c == ':'
}

fn read_number(lex: Lexer) -> (Lexer, Token) {
    var current: Lexer = lex
    let start: i32 = current.pos
    var has_dot: bool = false
    var has_exp: bool = false

    let first: char = current_char(current)
    if first == '+' or first == '-' { current = advance(current) }

    while not is_at_end(current) and is_digit(current_char(current)) {
        current = advance(current)
    }

    if not is_at_end(current) and current_char(current) == '.' {
        let next: char = peek_char(current, 1)
        if is_digit(next) {
            has_dot = true
            current = advance(current)
            while not is_at_end(current) and is_digit(current_char(current)) {
                current = advance(current)
            }
        }
    }

    if not is_at_end(current) {
        let exp_char: char = current_char(current)
        if exp_char == 'e' or exp_char == 'E' {
            has_exp = true
            current = advance(current)
            let sign: char = current_char(current)
            if sign == '+' or sign == '-' { current = advance(current) }
            while not is_at_end(current) and is_digit(current_char(current)) {
                current = advance(current)
            }
        }
    }

    let num_str: string = substr(lex.input, start, current.pos)

    // TODO: Add float parsing when Kira supports it
    // For now, treat all numbers as integers
    match std.string.parse_int(num_str) {
        Some(n) => { return (current, TokInt(n)) }
        None => { return (current, TokInt(0i64)) }
    }
}

fn read_string(lex: Lexer) -> Result[(Lexer, Token), (string, SourceLoc)] {
    let start_loc: SourceLoc = lexer_loc(lex)
    var current: Lexer = advance(lex)
    var sb: StringBuilder = std.builder.new()

    while not is_at_end(current) {
        let c: char = current_char(current)
        if c == '"' {
            current = advance(current)
            return Ok((current, TokString(std.builder.build(sb))))
        } else if c == '\\' {
            current = advance(current)
            if is_at_end(current) {
                return Err(("Unexpected end in string escape", lexer_loc(current)))
            }
            let escaped: char = current_char(current)
            match escaped {
                'n' => { sb = std.builder.append_char(sb, '\n') }
                't' => { sb = std.builder.append_char(sb, '\t') }
                'r' => { sb = std.builder.append_char(sb, '\r') }
                '\\' => { sb = std.builder.append_char(sb, '\\') }
                '"' => { sb = std.builder.append_char(sb, '"') }
                _ => { sb = std.builder.append_char(sb, escaped) }
            }
            current = advance(current)
        } else {
            sb = std.builder.append_char(sb, c)
            current = advance(current)
        }
    }
    return Err(("Unterminated string", start_loc))
}

fn read_symbol(lex: Lexer) -> (Lexer, Token) {
    var current: Lexer = lex
    let start: i32 = current.pos
    while not is_at_end(current) and is_symbol_char(current_char(current)) {
        current = advance(current)
    }
    let symbol: string = substr(lex.input, start, current.pos)
    return (current, TokSymbol(symbol))
}

fn looking_at_number(lex: Lexer) -> bool {
    let c: char = current_char(lex)
    if is_digit(c) { return true }
    if (c == '+' or c == '-') {
        let next: char = peek_char(lex, 1)
        return is_digit(next)
    }
    return false
}

fn next_token(lex: Lexer) -> Result[(Lexer, Token, SourceLoc), (string, SourceLoc)] {
    var current: Lexer = skip_whitespace_and_comments(lex)
    if is_at_end(current) {
        return Ok((current, TokEOF, lexer_loc(current)))
    }
    let token_loc: SourceLoc = lexer_loc(current)
    let c: char = current_char(current)

    if c == '(' { return Ok((advance(current), TokLParen, token_loc)) }
    if c == ')' { return Ok((advance(current), TokRParen, token_loc)) }
    if c == '\'' { return Ok((advance(current), TokQuote, token_loc)) }
    if c == '`' { return Ok((advance(current), TokQuasiquote, token_loc)) }
    if c == ',' {
        let next: char = peek_char(current, 1)
        if next == '@' {
            return Ok((advance(advance(current)), TokUnquoteSplicing, token_loc))
        }
        return Ok((advance(current), TokUnquote, token_loc))
    }
    if c == '"' {
        match read_string(current) {
            Ok((new_lex, tok)) => { return Ok((new_lex, tok, token_loc)) }
            Err((msg, loc)) => { return Err((msg, loc)) }
        }
    }

    if c == '#' {
        let next: char = peek_char(current, 1)
        if next == 't' { return Ok((advance(advance(current)), TokBool(true), token_loc)) }
        if next == 'f' { return Ok((advance(advance(current)), TokBool(false), token_loc)) }
        return Err(("Invalid # literal", token_loc))
    }

    if looking_at_number(current) {
        let (new_lex, tok): (Lexer, Token) = read_number(current)
        return Ok((new_lex, tok, token_loc))
    }

    if is_symbol_start(c) {
        let (new_lex, tok): (Lexer, Token) = read_symbol(current)
        return Ok((new_lex, tok, token_loc))
    }

    return Err(("Unexpected character", token_loc))
}

effect fn tokenize(input: string, file: string) -> LexResult {
    var lex: Lexer = lexer_new(input, file)
    var tokens: List[LocatedToken] = Nil

    loop {
        match next_token(lex) {
            Ok((new_lex, token, loc)) => {
                tokens = Cons(LocatedToken { token: token, loc: loc }, tokens)
                lex = new_lex
                match token {
                    TokEOF => { break }
                    _ => { }
                }
            }
            Err((msg, loc)) => { return LexErr(msg, loc) }
        }
    }
    return LexOk(std.list.reverse(tokens))
}

// ============================================================================
// Parser
// ============================================================================

// Helper to get location from first token in list
fn first_token_loc(tokens: List[LocatedToken]) -> Option[SourceLoc] {
    match tokens {
        Nil => { return None }
        Cons(lt, _) => { return Some(lt.loc) }
    }
}

fn parse_expr(tokens: List[LocatedToken]) -> ParseResult {
    match tokens {
        Nil => { return ParseErr("Unexpected end of input", None) }
        Cons(lt, rest) => {
            let loc: SourceLoc = lt.loc
            match lt.token {
                TokInt(n) => { return ParseOk(LispInt(n), rest) }
                TokFloat(n) => { return ParseOk(LispFloat(n), rest) }
                TokString(s) => { return ParseOk(LispString(s), rest) }
                TokSymbol(s) => { return ParseOk(LispSymbol(s, Some(loc)), rest) }
                TokBool(b) => { return ParseOk(LispBool(b), rest) }
                TokLParen => { return parse_list(rest, loc) }
                TokRParen => { return ParseErr("Unexpected )", Some(loc)) }
                TokQuote => { return parse_quoted(rest, loc) }
                TokQuasiquote => { return parse_quasiquoted(rest, loc) }
                TokUnquote => { return parse_unquoted(rest, loc) }
                TokUnquoteSplicing => { return parse_unquote_spliced(rest, loc) }
                TokEOF => { return ParseErr("Unexpected EOF", Some(loc)) }
            }
        }
    }
}

fn parse_list(tokens: List[LocatedToken], open_loc: SourceLoc) -> ParseResult {
    var current: List[LocatedToken] = tokens
    var elements: List[LispValue] = Nil

    loop {
        match current {
            Nil => { return ParseErr("Unclosed list", Some(open_loc)) }
            Cons(lt, rest) => {
                match lt.token {
                    TokRParen => {
                        return ParseOk(LispList(std.list.reverse(elements), Some(open_loc)), rest)
                    }
                    TokEOF => { return ParseErr("Unclosed list at EOF", Some(open_loc)) }
                    _ => {
                        match parse_expr(current) {
                            ParseOk(value, remaining) => {
                                elements = Cons(value, elements)
                                current = remaining
                            }
                            ParseErr(msg, loc) => { return ParseErr(msg, loc) }
                        }
                    }
                }
            }
        }
    }
}

fn parse_quoted(tokens: List[LocatedToken], quote_loc: SourceLoc) -> ParseResult {
    match parse_expr(tokens) {
        ParseOk(value, rest) => {
            let quote_sym: LispValue = LispSymbol("quote", Some(quote_loc))
            let quoted: LispValue = LispList(Cons(quote_sym, Cons(value, Nil)), Some(quote_loc))
            return ParseOk(quoted, rest)
        }
        ParseErr(msg, loc) => { return ParseErr(msg, loc) }
    }
}

fn parse_quasiquoted(tokens: List[LocatedToken], qq_loc: SourceLoc) -> ParseResult {
    match parse_expr(tokens) {
        ParseOk(value, rest) => {
            let qq_sym: LispValue = LispSymbol("quasiquote", Some(qq_loc))
            let quoted: LispValue = LispList(Cons(qq_sym, Cons(value, Nil)), Some(qq_loc))
            return ParseOk(quoted, rest)
        }
        ParseErr(msg, loc) => { return ParseErr(msg, loc) }
    }
}

fn parse_unquoted(tokens: List[LocatedToken], uq_loc: SourceLoc) -> ParseResult {
    match parse_expr(tokens) {
        ParseOk(value, rest) => {
            let uq_sym: LispValue = LispSymbol("unquote", Some(uq_loc))
            let unquoted: LispValue = LispList(Cons(uq_sym, Cons(value, Nil)), Some(uq_loc))
            return ParseOk(unquoted, rest)
        }
        ParseErr(msg, loc) => { return ParseErr(msg, loc) }
    }
}

fn parse_unquote_spliced(tokens: List[LocatedToken], uqs_loc: SourceLoc) -> ParseResult {
    match parse_expr(tokens) {
        ParseOk(value, rest) => {
            let uqs_sym: LispValue = LispSymbol("unquote-splicing", Some(uqs_loc))
            let spliced: LispValue = LispList(Cons(uqs_sym, Cons(value, Nil)), Some(uqs_loc))
            return ParseOk(spliced, rest)
        }
        ParseErr(msg, loc) => { return ParseErr(msg, loc) }
    }
}

fn parse_all(tokens: List[LocatedToken]) -> ParseAllResult {
    var current: List[LocatedToken] = tokens
    var exprs: List[LispValue] = Nil

    loop {
        match current {
            Nil => { return ParseAllOk(std.list.reverse(exprs)) }
            Cons(lt, _) => {
                match lt.token {
                    TokEOF => { return ParseAllOk(std.list.reverse(exprs)) }
                    _ => {
                        match parse_expr(current) {
                            ParseOk(value, remaining) => {
                                exprs = Cons(value, exprs)
                                current = remaining
                            }
                            ParseErr(msg, loc) => { return ParseAllErr(msg, loc) }
                        }
                    }
                }
            }
        }
    }
}

// ============================================================================
// Environment (using association list instead of HashMap for simplicity)
// ============================================================================

// Binding is a name-value pair
type Binding = (string, LispValue)

// Environment is a list of bindings plus optional parent
type EnvData = {
    bindings: List[Binding],
    parent: Option[Env]
}

fn env_new() -> Env {
    return Env { bindings: std.map.new(), parent: None }
}

// Helper to reverse a list of LispValues
fn lisp_reverse(lst: List[LispValue]) -> List[LispValue] {
    var result: List[LispValue] = Nil
    var current: List[LispValue] = lst
    loop {
        match current {
            Nil => { break }
            Cons(head, tail) => {
                result = Cons(head, result)
                current = tail
            }
        }
    }
    return result
}

fn env_extend(parent: Env) -> Env {
    return Env { bindings: std.map.new(), parent: Some(parent) }
}

// Helper to lookup in a binding list
fn lookup_in_bindings(bindings: List[Binding], name: string) -> Option[LispValue] {
    match bindings {
        Nil => { return None }
        Cons(binding, rest) => {
            let (bname, bvalue): (string, LispValue) = binding
            if bname == name {
                return Some(bvalue)
            }
            return lookup_in_bindings(rest, name)
        }
    }
}

fn env_define(env: Env, name: string, value: LispValue) -> Env {
    let new_bindings: HashMap = std.map.put(env.bindings, name, value)
    return Env { bindings: new_bindings, parent: env.parent }
}

fn env_lookup(env: Env, name: string) -> Option[LispValue] {
    match std.map.get(env.bindings, name) {
        Some(value) => {
            // Cast from any to LispValue
            return Some(value)
        }
        None => {
            match env.parent {
                Some(parent) => { return env_lookup(parent, name) }
                None => { return None }
            }
        }
    }
}

fn env_set(env: Env, name: string, value: LispValue) -> Result[Env, string] {
    if std.map.contains(env.bindings, name) {
        let new_bindings: HashMap = std.map.put(env.bindings, name, value)
        return Ok(Env { bindings: new_bindings, parent: env.parent })
    } else {
        match env.parent {
            Some(parent) => {
                match env_set(parent, name, value) {
                    Ok(new_parent) => {
                        return Ok(Env { bindings: env.bindings, parent: Some(new_parent) })
                    }
                    Err(msg) => { return Err(msg) }
                }
            }
            None => { return Err("Undefined variable: " + name) }
        }
    }
}

fn env_define_all(env: Env, names: List[string], values: List[LispValue]) -> Result[Env, string] {
    var current_env: Env = env
    var name_list: List[string] = names
    var value_list: List[LispValue] = values

    loop {
        match (name_list, value_list) {
            (Nil, Nil) => { return Ok(current_env) }
            (Cons(name, rest_names), Cons(value, rest_values)) => {
                current_env = env_define(current_env, name, value)
                name_list = rest_names
                value_list = rest_values
            }
            (Nil, Cons(_, _)) => { return Err("Too many arguments") }
            (Cons(_, _), Nil) => { return Err("Not enough arguments") }
        }
    }
}

// ============================================================================
// Evaluator
// ============================================================================

// Helper to get location from a LispValue
fn get_loc(v: LispValue) -> Option[SourceLoc] {
    match v {
        LispSymbol(_, loc) => { return loc }
        LispList(_, loc) => { return loc }
        _ => { return None }
    }
}

fn lisp_to_string(v: LispValue) -> string {
    match v {
        LispNil => { return "()" }
        LispBool(b) => { if b { return "#t" } else { return "#f" } }
        LispInt(n) => { return to_string(n) }
        LispFloat(n) => { return to_string(n) }
        LispString(s) => { return "\"" + s + "\"" }
        LispSymbol(s, _) => { return s }
        LispList(items, _) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "(")
            var first: bool = true
            for item in items {
                if not first { sb = std.builder.append(sb, " ") }
                sb = std.builder.append(sb, lisp_to_string(item))
                first = false
            }
            sb = std.builder.append(sb, ")")
            return std.builder.build(sb)
        }
        LispLambda(params, _, _) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "#<lambda (")
            var first: bool = true
            for p in params {
                if not first { sb = std.builder.append(sb, " ") }
                sb = std.builder.append(sb, p)
                first = false
            }
            sb = std.builder.append(sb, ")>")
            return std.builder.build(sb)
        }
        LispRecursiveLambda(name, params, _, _) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "#<lambda ")
            sb = std.builder.append(sb, name)
            sb = std.builder.append(sb, " (")
            var first: bool = true
            for p in params {
                if not first { sb = std.builder.append(sb, " ") }
                sb = std.builder.append(sb, p)
                first = false
            }
            sb = std.builder.append(sb, ")>")
            return std.builder.build(sb)
        }
        LispBuiltin(name) => { return "#<builtin:" + name + ">" }
        LispMacro(params, _, _) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "#<macro (")
            var first: bool = true
            for p in params {
                if not first { sb = std.builder.append(sb, " ") }
                sb = std.builder.append(sb, p)
                first = false
            }
            sb = std.builder.append(sb, ")>")
            return std.builder.build(sb)
        }
    }
}

fn is_truthy(v: LispValue) -> bool {
    match v { LispBool(b) => { return b } _ => { return true } }
}

// ============================================================================
// Tail Call Optimization (Trampoline)
// ============================================================================

// The trampoline keeps evaluating until we get a final result (not a TailCall)
// This implements proper tail recursion without growing the stack
effect fn trampoline(initial: EvalResult) -> EvalResult {
    var current: EvalResult = initial
    loop {
        match current {
            TailCall(func, args, env) => {
                // Apply the function without recursion
                current = apply_tail(func, args, env)
            }
            EvalOk(_, _) => { return current }
            EvalErr(_, _) => { return current }
        }
    }
}

// Evaluate an expression with TCO support
// This is the main entry point for evaluation from REPL/file execution
effect fn eval_tco(expr: LispValue, env: Env) -> EvalResult {
    return trampoline(eval(expr, env))
}

effect fn eval(expr: LispValue, env: Env) -> EvalResult {
    match expr {
        LispNil => { return EvalOk(LispNil, env) }
        LispBool(b) => { return EvalOk(LispBool(b), env) }
        LispInt(n) => { return EvalOk(LispInt(n), env) }
        LispFloat(n) => { return EvalOk(LispFloat(n), env) }
        LispString(s) => { return EvalOk(LispString(s), env) }
        LispSymbol(name, loc) => {
            match env_lookup(env, name) {
                Some(value) => { return EvalOk(value, env) }
                None => { return EvalErr("Undefined variable: " + name, loc) }
            }
        }
        LispList(items, loc) => {
            match items {
                Nil => { return EvalOk(LispNil, env) }
                Cons(first, rest) => { return eval_list(first, rest, loc, env) }
            }
        }
        LispLambda(p, b, e) => { return EvalOk(LispLambda(p, b, e), env) }
        LispRecursiveLambda(n, p, b, e) => { return EvalOk(LispRecursiveLambda(n, p, b, e), env) }
        LispBuiltin(n) => { return EvalOk(LispBuiltin(n), env) }
        LispMacro(p, b, e) => { return EvalOk(LispMacro(p, b, e), env) }
    }
}

effect fn eval_list(first: LispValue, rest: List[LispValue], list_loc: Option[SourceLoc], env: Env) -> EvalResult {
    match first {
        LispSymbol(name, _) => {
            if name == "quote" { return eval_quote(rest, list_loc, env) }
            if name == "quasiquote" { return eval_quasiquote(rest, list_loc, env) }
            if name == "defmacro" { return eval_defmacro(rest, list_loc, env) }
            if name == "if" { return eval_if(rest, list_loc, env) }
            if name == "define" { return eval_define(rest, list_loc, env) }
            if name == "lambda" { return eval_lambda(rest, list_loc, env) }
            if name == "let" { return eval_let(rest, list_loc, env) }
            if name == "begin" { return eval_begin(rest, env) }
            if name == "set!" { return eval_set(rest, list_loc, env) }
            if name == "and" { return eval_and(rest, env) }
            if name == "or" { return eval_or(rest, env) }
            if name == "import" { return eval_import(rest, env) }
            if name == "provide" { return eval_provide(rest, list_loc, env) }
            if name == "try" { return eval_try(rest, list_loc, env) }
            if name == "assert-throws" { return eval_assert_throws(rest, list_loc, env) }
            // Check if it's a macro call
            match env_lookup(env, name) {
                Some(LispMacro(_, _, _)) => { return eval_macro_call(name, rest, env) }
                _ => { }
            }
            return eval_application(first, rest, list_loc, env)
        }
        _ => { return eval_application(first, rest, list_loc, env) }
    }
}

fn eval_quote(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(value, Nil) => { return EvalOk(value, env) }
        _ => { return EvalErr("quote requires one argument", loc) }
    }
}

// ============================================================================
// Quasiquote Evaluation
// ============================================================================

effect fn eval_quasiquote(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(expr, Nil) => {
            return eval_qq(expr, 1, env)
        }
        _ => { return EvalErr("quasiquote requires one argument", loc) }
    }
}

// Recursively process quasiquoted expression with depth tracking
effect fn eval_qq(expr: LispValue, depth: i32, env: Env) -> EvalResult {
    match expr {
        LispList(items, loc) => {
            match items {
                Nil => { return EvalOk(LispList(Nil, None), env) }
                Cons(first, rest) => {
                    // Check for special forms
                    match first {
                        LispSymbol(name, sym_loc) => {
                            if name == "unquote" {
                                if depth == 1 {
                                    // At depth 1, evaluate the unquoted expression
                                    match rest {
                                        Cons(unq_expr, Nil) => {
                                            return trampoline(eval(unq_expr, env))
                                        }
                                        _ => { return EvalErr("unquote requires one argument", sym_loc) }
                                    }
                                } else {
                                    // Nested unquote - decrement depth and recurse
                                    return eval_qq_list(items, depth - 1, env)
                                }
                            }
                            if name == "quasiquote" {
                                // Nested quasiquote - increment depth
                                return eval_qq_list(items, depth + 1, env)
                            }
                            if name == "unquote-splicing" {
                                // unquote-splicing at top level of list is an error
                                return EvalErr("unquote-splicing not in list context", sym_loc)
                            }
                            // Regular list - process elements with splicing support
                            return eval_qq_list(items, depth, env)
                        }
                        _ => {
                            // Regular list - process elements with splicing support
                            return eval_qq_list(items, depth, env)
                        }
                    }
                }
            }
        }
        // Non-list values are returned as-is (like quote)
        _ => { return EvalOk(expr, env) }
    }
}

// Process list elements, handling unquote-splicing
effect fn eval_qq_list(items: List[LispValue], depth: i32, env: Env) -> EvalResult {
    var result: List[LispValue] = Nil
    var current: List[LispValue] = items

    loop {
        match current {
            Nil => { break }
            Cons(item, rest) => {
                // Check if this item is (unquote-splicing expr) at depth 1
                match item {
                    LispList(Cons(LispSymbol(name, sym_loc), splice_rest), _) => {
                        if name == "unquote-splicing" and depth == 1 {
                            match splice_rest {
                                Cons(splice_expr, Nil) => {
                                    // Evaluate the expression
                                    match trampoline(eval(splice_expr, env)) {
                                        EvalOk(splice_val, _) => {
                                            // Splice the list into result
                                            match splice_val {
                                                LispList(splice_items, _) => {
                                                    // Add each item from spliced list
                                                    for splice_item in splice_items {
                                                        result = Cons(splice_item, result)
                                                    }
                                                }
                                                _ => { return EvalErr("unquote-splicing requires a list", sym_loc) }
                                            }
                                        }
                                        EvalErr(msg, loc) => { return EvalErr(msg, loc) }
                                        TailCall(_, _, _) => { return EvalErr("Internal error", None) }
                                    }
                                    current = rest
                                }
                                _ => { return EvalErr("unquote-splicing requires one argument", sym_loc) }
                            }
                        } else {
                            // Regular item - recursively process
                            match eval_qq(item, depth, env) {
                                EvalOk(val, _) => {
                                    result = Cons(val, result)
                                    current = rest
                                }
                                EvalErr(msg, loc) => { return EvalErr(msg, loc) }
                                TailCall(_, _, _) => { return EvalErr("Internal error", None) }
                            }
                        }
                    }
                    _ => {
                        // Regular item - recursively process
                        match eval_qq(item, depth, env) {
                            EvalOk(val, _) => {
                                result = Cons(val, result)
                                current = rest
                            }
                            EvalErr(msg, loc) => { return EvalErr(msg, loc) }
                            TailCall(_, _, _) => { return EvalErr("Internal error", None) }
                        }
                    }
                }
            }
        }
    }

    return EvalOk(LispList(std.list.reverse(result), None), env)
}

// ============================================================================
// Macro Definition and Expansion
// ============================================================================

fn eval_defmacro(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(name, _), Cons(LispList(params, _), body)) => {
            match extract_param_names(params) {
                Ok(param_names) => {
                    let macro_body: LispValue = make_begin(body)
                    let macro_val: LispValue = LispMacro(param_names, macro_body, env)
                    let new_env: Env = env_define(env, name, macro_val)
                    return EvalOk(LispNil, new_env)
                }
                Err(msg) => { return EvalErr(msg, loc) }
            }
        }
        _ => { return EvalErr("defmacro: invalid syntax - expected (defmacro name (params...) body...)", loc) }
    }
}

effect fn eval_macro_call(name: string, args: List[LispValue], env: Env) -> EvalResult {
    match env_lookup(env, name) {
        Some(LispMacro(params, body, macro_env)) => {
            // Bind unevaluated args to params (macros don't evaluate arguments)
            let call_env: Env = env_extend(macro_env)
            match env_define_all(call_env, params, args) {
                Ok(bound_env) => {
                    // Evaluate macro body to get expanded form
                    match trampoline(eval(body, bound_env)) {
                        EvalOk(expanded, _) => {
                            // Evaluate expanded form in the caller's environment
                            return eval(expanded, env)
                        }
                        EvalErr(msg, loc) => { return EvalErr("Macro expansion error: " + msg, loc) }
                        TailCall(_, _, _) => { return EvalErr("Internal error", None) }
                    }
                }
                Err(msg) => { return EvalErr(msg, None) }
            }
        }
        _ => { return EvalErr("Not a macro: " + name, None) }
    }
}

effect fn eval_if(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(cond, Cons(then_expr, else_part)) => {
            // Condition must be fully evaluated (not in tail position)
            match trampoline(eval(cond, env)) {
                EvalOk(cond_val, _) => {
                    // Then/else branches are in tail position - propagate TailCall
                    // Use original env, not the env returned by condition evaluation
                    if is_truthy(cond_val) {
                        return eval(then_expr, env)
                    } else {
                        match else_part {
                            Cons(else_expr, Nil) => { return eval(else_expr, env) }
                            Nil => { return EvalOk(LispNil, env) }
                            _ => { return EvalErr("if: too many arguments", loc) }
                        }
                    }
                }
                EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
        _ => { return EvalErr("if requires 2-3 arguments", loc) }
    }
}

effect fn eval_define(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(name, _), Cons(value_expr, Nil)) => {
            // Value is not in tail position - fully evaluate
            match trampoline(eval(value_expr, env)) {
                EvalOk(value, _) => {
                    // Use original env - don't let function calls during value evaluation pollute bindings
                    let new_env: Env = env_define(env, name, value)
                    return EvalOk(LispNil, new_env)
                }
                EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
        Cons(LispList(name_and_params, _), body) => {
            match name_and_params {
                Cons(LispSymbol(name, _), params) => {
                    match extract_param_names(params) {
                        Ok(param_names) => {
                            let lambda_body: LispValue = make_begin(body)
                            // Use LispRecursiveLambda for named function definitions
                            // This stores the function name so apply can inject self-reference
                            let lambda: LispValue = LispRecursiveLambda(name, param_names, lambda_body, env)
                            let new_env: Env = env_define(env, name, lambda)
                            return EvalOk(LispNil, new_env)
                        }
                        Err(msg) => { return EvalErr(msg, loc) }
                    }
                }
                _ => { return EvalErr("define: invalid function definition", loc) }
            }
        }
        _ => { return EvalErr("define: invalid syntax", loc) }
    }
}

fn extract_param_names(params: List[LispValue]) -> Result[List[string], string] {
    var names: List[string] = Nil
    for p in params {
        match p {
            LispSymbol(name, _) => { names = Cons(name, names) }
            _ => { return Err("Parameter must be a symbol") }
        }
    }
    return Ok(std.list.reverse(names))
}

fn make_begin(body: List[LispValue]) -> LispValue {
    match body {
        Cons(single, Nil) => { return single }
        _ => { return LispList(Cons(LispSymbol("begin", None), body), None) }
    }
}

fn eval_lambda(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(params, _), body) => {
            match extract_param_names(params) {
                Ok(param_names) => {
                    let lambda_body: LispValue = make_begin(body)
                    return EvalOk(LispLambda(param_names, lambda_body, env), env)
                }
                Err(msg) => { return EvalErr(msg, loc) }
            }
        }
        _ => { return EvalErr("lambda: invalid syntax", loc) }
    }
}

effect fn eval_let(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(bindings, _), body) => {
            var let_env: Env = env_extend(env)
            for binding in bindings {
                match binding {
                    LispList(Cons(LispSymbol(name, _), Cons(value_expr, Nil)), _) => {
                        // Binding values are not in tail position - fully evaluate
                        match trampoline(eval(value_expr, env)) {
                            EvalOk(value, _) => { let_env = env_define(let_env, name, value) }
                            EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
                            TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
                        }
                    }
                    _ => { return EvalErr("let: invalid binding", loc) }
                }
            }
            // Body is in tail position - will propagate TailCall
            return eval_begin_list(body, let_env)
        }
        _ => { return EvalErr("let: invalid syntax", loc) }
    }
}

effect fn eval_begin(args: List[LispValue], env: Env) -> EvalResult {
    return eval_begin_list(args, env)
}

// Check if an expression is a binding form that modifies the environment
fn is_binding_form(expr: LispValue) -> bool {
    match expr {
        LispList(Cons(LispSymbol(name, _), _), _) => {
            return name == "define" or name == "set!" or name == "defmacro" or name == "import"
        }
        _ => { return false }
    }
}

// Evaluate a sequence of expressions, with the last one in tail position
effect fn eval_begin_list(exprs: List[LispValue], env: Env) -> EvalResult {
    match exprs {
        Nil => { return EvalOk(LispNil, env) }
        Cons(last_expr, Nil) => {
            // Single expression - it's in tail position
            return eval(last_expr, env)
        }
        Cons(first_expr, rest) => {
            // Not the last - fully evaluate it
            match trampoline(eval(first_expr, env)) {
                EvalOk(_, new_env) => {
                    // Only use new_env for binding forms (define, set!, defmacro)
                    // For all other expressions (esp. function calls), use original env
                    // This prevents callee's environment from polluting the caller's scope
                    if is_binding_form(first_expr) {
                        return eval_begin_list(rest, new_env)
                    } else {
                        return eval_begin_list(rest, env)
                    }
                }
                EvalErr(msg, loc) => { return EvalErr(msg, loc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
    }
}

effect fn eval_set(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(name, sym_loc), Cons(value_expr, Nil)) => {
            // Value is not in tail position - fully evaluate
            match trampoline(eval(value_expr, env)) {
                EvalOk(value, env2) => {
                    match env_set(env2, name, value) {
                        Ok(new_env) => { return EvalOk(LispNil, new_env) }
                        Err(msg) => { return EvalErr(msg, sym_loc) }
                    }
                }
                EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
        _ => { return EvalErr("set! requires variable and value", loc) }
    }
}

// and: (and e1 e2 ... en) - last expression is in tail position
effect fn eval_and(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Nil => { return EvalOk(LispBool(true), env) }
        Cons(last_arg, Nil) => {
            // Last argument is in tail position
            return eval(last_arg, env)
        }
        Cons(first_arg, rest) => {
            // Not last - fully evaluate
            match trampoline(eval(first_arg, env)) {
                EvalOk(value, _) => {
                    // Use original env - don't let function calls pollute the environment
                    if not is_truthy(value) {
                        return EvalOk(LispBool(false), env)
                    }
                    return eval_and(rest, env)
                }
                EvalErr(msg, loc) => { return EvalErr(msg, loc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
    }
}

// or: (or e1 e2 ... en) - last expression is in tail position
effect fn eval_or(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Nil => { return EvalOk(LispBool(false), env) }
        Cons(last_arg, Nil) => {
            // Last argument is in tail position
            return eval(last_arg, env)
        }
        Cons(first_arg, rest) => {
            // Not last - fully evaluate
            match trampoline(eval(first_arg, env)) {
                EvalOk(value, _) => {
                    // Use original env - don't let function calls pollute the environment
                    if is_truthy(value) {
                        return EvalOk(value, env)
                    }
                    return eval_or(rest, env)
                }
                EvalErr(msg, loc) => { return EvalErr(msg, loc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
    }
}

// ============================================================================
// Module System: import and provide
// ============================================================================
//
// Supported:
//   (import "path/to/module.lisp")  - imports all definitions from module
//   (provide sym1 sym2 ...)          - declares exported symbols
//
// Limitations due to Kira bugs with HashMap/any types and recursive types:
//   - Explicit symbol lists in import not yet supported
//   - Circular import detection is disabled
//   - Module exports (provide) are recorded but not enforced during import
//
// ============================================================================

// Check if a module has been loaded (tracked via __loaded_modules__ binding)
// NOTE: Currently unused due to Kira HashMap/any type bugs
fn is_module_loaded(env: Env, path: string) -> bool {
    match env_lookup(env, "__loaded_modules__") {
        Some(LispList(modules, _)) => {
            return list_contains_string(modules, path)
        }
        _ => { return false }
    }
}

// Check if a list of LispValues contains a string
fn list_contains_string(list: List[LispValue], target: string) -> bool {
    match list {
        Nil => { return false }
        Cons(LispString(s), rest) => {
            if s == target { return true }
            return list_contains_string(rest, target)
        }
        Cons(_, rest) => { return list_contains_string(rest, target) }
    }
}

// Add a module path to the loaded modules list
fn mark_module_loaded(env: Env, path: string) -> Env {
    let modules: List[LispValue] = match env_lookup(env, "__loaded_modules__") {
        Some(LispList(existing, _)) => { existing }
        _ => { Nil }
    }
    let new_modules: List[LispValue] = Cons(LispString(path), modules)
    return env_define(env, "__loaded_modules__", LispList(new_modules, None))
}

// Get the list of exported symbols from a module environment
fn get_exports(env: Env) -> Option[List[string]] {
    match env_lookup(env, "__exports__") {
        Some(LispList(exports, _)) => {
            return Some(extract_symbols(exports))
        }
        _ => { return None }
    }
}

// Extract symbol names from a list of LispSymbol values
fn extract_symbols(values: List[LispValue]) -> List[string] {
    match values {
        Nil => { return Nil }
        Cons(LispSymbol(name, _), rest) => { return Cons(name, extract_symbols(rest)) }
        Cons(_, rest) => { return extract_symbols(rest) }
    }
}

// Check if a name is in a list of strings
fn name_in_list(name: string, list: List[string]) -> bool {
    match list {
        Nil => { return false }
        Cons(s, rest) => {
            if s == name { return true }
            return name_in_list(name, rest)
        }
    }
}

// Helper: recursively import symbols from a list of names
fn import_names_recursive(target: Env, source: Env, names: List[string]) -> Result[Env, string] {
    match names {
        Nil => { return Ok(target) }
        Cons(name, rest) => {
            match env_lookup(source, name) {
                Some(value) => {
                    let new_target: Env = env_define(target, name, value)
                    return import_names_recursive(new_target, source, rest)
                }
                None => {
                    return Err("import: symbol not found in module: " + name)
                }
            }
        }
    }
}

// Helper: recursively import all non-internal keys
fn import_keys_recursive(target: Env, source: Env, keys: List[string]) -> Env {
    match keys {
        Nil => { return target }
        Cons(key, rest) => {
            if std.string.starts_with(key, "__") {
                // skip internal bindings
                return import_keys_recursive(target, source, rest)
            } else {
                match env_lookup(source, key) {
                    Some(value) => {
                        let new_target: Env = env_define(target, key, value)
                        return import_keys_recursive(new_target, source, rest)
                    }
                    None => {
                        return import_keys_recursive(target, source, rest)
                    }
                }
            }
        }
    }
}

// Simple version: import specific symbols by name
// Uses recursive functions to avoid for-loop issues with HashMap/any types
fn import_bindings_simple(target: Env, source: Env, only_symbols: Option[List[string]]) -> Result[Env, string] {
    match only_symbols {
        Some(requested) => {
            // Import only requested symbols
            return import_names_recursive(target, source, requested)
        }
        None => {
            // No explicit list - import all non-internal symbols
            // Note: exports list check is disabled due to Kira HashMap/any type issues
            let source_bindings: HashMap = source.bindings
            let keys: List[string] = std.map.keys(source_bindings)
            return Ok(import_keys_recursive(target, source, keys))
        }
    }
}

// (import "path.lisp")
// (import "path.lisp" (sym1 sym2 ...))
// (import "path.lisp" :as prefix)
effect fn eval_import(args: List[LispValue], env: Env) -> EvalResult {
    match args {
        Cons(LispString(path), rest) => {
            // Check for circular import
            if is_module_loaded(env, path) {
                // Already loaded - just return success
                return EvalOk(LispNil, env)
            }

            // Check for optional symbol list argument
            // NOTE: Due to Kira bug with matching on List[LispValue], we need to
            // check length first before matching on the content
            let has_extra_args: bool = match rest {
                Nil => { false }
                _ => { true }
            }

            // For now, import all symbols (explicit symbol lists disabled)
            let only_symbols: Option[List[string]] = None
            let env_with_loading: Env = env

            // Read and parse the file
            match std.fs.read_file(path) {
                Ok(content) => {
                    match tokenize(content, path) {
                        LexOk(tokens) => {
                            match parse_all(tokens) {
                                ParseAllOk(exprs) => {
                                    // Create fresh environment for module
                                    let module_env: Env = make_initial_env()

                                    // Evaluate module
                                    match trampoline(eval_begin_list(exprs, module_env)) {
                                        EvalOk(_, final_module_env) => {
                                            // Import bindings from module into caller's env
                                            match import_bindings_simple(env_with_loading, final_module_env, only_symbols) {
                                                Ok(new_env) => {
                                                    return EvalOk(LispNil, new_env)
                                                }
                                                Err(msg) => { return EvalErr(msg, None) }
                                            }
                                        }
                                        EvalErr(msg, loc) => {
                                            return EvalErr("import: error in module '" + path + "': " + msg, loc)
                                        }
                                        TailCall(_, _, _) => {
                                            return EvalErr("Internal error in import", None)
                                        }
                                    }
                                }
                                ParseAllErr(msg, loc) => {
                                    return EvalErr("import: parse error in '" + path + "': " + msg, loc)
                                }
                            }
                        }
                        LexErr(msg, loc) => {
                            return EvalErr("import: lex error in '" + path + "': " + msg, Some(loc))
                        }
                    }
                }
                Err(msg) => {
                    return EvalErr("import: cannot read file '" + path + "': " + msg, None)
                }
            }
        }
        _ => {
            return EvalErr("import: expected string path - (import \"path.lisp\" [(symbols...)])", None)
        }
    }
}

// (provide sym1 sym2 ...)
// Declares which symbols this module exports
fn eval_provide(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    // Build list of exported symbol names
    var exports: List[LispValue] = match env_lookup(env, "__exports__") {
        Some(LispList(existing, _)) => { existing }
        _ => { Nil }
    }

    for arg in args {
        match arg {
            LispSymbol(name, _) => {
                exports = Cons(LispSymbol(name, None), exports)
            }
            _ => {
                return EvalErr("provide: expected symbols, got " + lisp_to_string(arg), loc)
            }
        }
    }

    let new_env: Env = env_define(env, "__exports__", LispList(exports, None))
    return EvalOk(LispNil, new_env)
}

// try special form: catches evaluation errors and returns (ok value) or (error "message")
effect fn eval_try(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(expr, Nil) => {
            match trampoline(eval(expr, env)) {
                EvalOk(value, new_env) => {
                    // Return (ok value)
                    let ok_sym: LispValue = LispSymbol("ok", None)
                    let result_list: List[LispValue] = Cons(ok_sym, Cons(value, Nil))
                    return EvalOk(LispList(result_list, None), new_env)
                }
                EvalErr(msg, _) => {
                    // Return (error "message")
                    let error_sym: LispValue = LispSymbol("error", None)
                    let result_list: List[LispValue] = Cons(error_sym, Cons(LispString(msg), Nil))
                    return EvalOk(LispList(result_list, None), env)
                }
                TailCall(_, _, _) => {
                    return EvalErr("Internal error: trampoline returned TailCall", None)
                }
            }
        }
        _ => {
            return EvalErr("try: requires exactly one argument", loc)
        }
    }
}

// assert-throws as a special form (doesn't evaluate its first argument before checking)
effect fn eval_assert_throws(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(expr, rest) => {
            var desc: string = "should throw"
            match rest {
                Cons(first_rest, Nil) => {
                    // Evaluate the description argument
                    match trampoline(eval(first_rest, env)) {
                        EvalOk(LispString(s), _) => { desc = s }
                        EvalOk(_, _) => { return EvalErr("assert-throws: second argument must be a string description", loc) }
                        EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
                        TailCall(_, _, _) => { return EvalErr("Internal error", None) }
                    }
                }
                Nil => { }
                _ => { return EvalErr("assert-throws: too many arguments", loc) }
            }
            var new_env: Env = inc_test_count(env, "__test_count__")
            // Try to evaluate the expression
            match trampoline(eval(expr, env)) {
                EvalOk(value, _) => {
                    // Expression succeeded - this is a failure for assert-throws
                    new_env = inc_test_count(new_env, "__fail_count__")
                    std.io.println("  FAIL: " + desc)
                    std.io.println("    Expected: error")
                    std.io.println("    Actual:   " + lisp_to_string(value))
                    return EvalOk(LispBool(false), new_env)
                }
                EvalErr(_, _) => {
                    // Expression threw an error - this is what we wanted
                    new_env = inc_test_count(new_env, "__pass_count__")
                    std.io.println("  PASS: " + desc)
                    return EvalOk(LispBool(true), new_env)
                }
                TailCall(_, _, _) => {
                    return EvalErr("Internal error: trampoline returned TailCall", None)
                }
            }
        }
        _ => { return EvalErr("assert-throws: requires one or two arguments (expr, [description])", loc) }
    }
}

effect fn eval_application(op_expr: LispValue, args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    // Operator is not in tail position - fully evaluate
    match trampoline(eval(op_expr, env)) {
        EvalOk(op, env2) => {
            match eval_list_values(args, env2) {
                // apply may return TailCall which will be propagated up
                EvalOk(LispList(arg_values, _), env3) => { return apply(op, arg_values, loc, env3) }
                EvalOk(_, _) => { return EvalErr("Internal error: eval_list_values didn't return list", None) }
                EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
                TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
            }
        }
        EvalErr(msg, eloc) => { return EvalErr(msg, eloc) }
        TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
    }
}

effect fn eval_list_values(exprs: List[LispValue], env: Env) -> EvalResult {
    // Evaluate all arguments in the SAME environment
    // This follows standard Scheme semantics: arguments don't see side effects from each other
    var values: List[LispValue] = Nil
    for expr in exprs {
        // Use trampoline to fully resolve each argument (strict evaluation)
        match trampoline(eval(expr, env)) {
            EvalOk(value, _) => {
                // Ignore the returned env - use original env for all args
                values = Cons(value, values)
            }
            EvalErr(msg, loc) => { return EvalErr(msg, loc) }
            TailCall(_, _, _) => { return EvalErr("Internal error: trampoline returned TailCall", None) }
        }
    }
    return EvalOk(LispList(std.list.reverse(values), None), env)
}

effect fn apply(func: LispValue, args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match func {
        LispLambda(params, body, closure_env) => {
            // Proper lexical scoping: extend the closure environment
            // Anonymous lambdas don't need self-reference
            let call_env: Env = env_extend(closure_env)
            match env_define_all(call_env, params, args) {
                Ok(bound_env) => {
                    // Return a TailCall to be handled by the trampoline
                    // This is the key to TCO - we don't recursively call eval here
                    return TailCall(body, Nil, bound_env)
                }
                Err(msg) => { return EvalErr(msg, loc) }
            }
        }
        LispRecursiveLambda(name, params, body, closure_env) => {
            // For named recursive functions: inject self-reference into closure
            // This allows the function to call itself by name
            let closure_with_self: Env = env_define(closure_env, name, func)
            let call_env: Env = env_extend(closure_with_self)
            match env_define_all(call_env, params, args) {
                Ok(bound_env) => {
                    return TailCall(body, Nil, bound_env)
                }
                Err(msg) => { return EvalErr(msg, loc) }
            }
        }
        LispBuiltin(name) => { return apply_builtin(name, args, loc, env) }
        _ => { return EvalErr("Cannot apply: " + lisp_to_string(func), loc) }
    }
}

// apply_tail is called by the trampoline to handle TailCall results
// It's different from apply because the "func" here is actually the body expression to evaluate
effect fn apply_tail(expr: LispValue, args: List[LispValue], env: Env) -> EvalResult {
    // The TailCall stores the body expression, empty args (not used), and the bound env
    return eval(expr, env)
}

// ============================================================================
// Built-in Functions
// ============================================================================

effect fn apply_builtin(name: string, args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    if name == "+" { return builtin_add(args, loc, env) }
    if name == "-" { return builtin_sub(args, loc, env) }
    if name == "*" { return builtin_mul(args, loc, env) }
    if name == "/" { return builtin_div(args, loc, env) }
    if name == "mod" { return builtin_mod(args, loc, env) }
    if name == "=" { return builtin_num_eq(args, loc, env) }
    if name == "<" { return builtin_lt(args, loc, env) }
    if name == ">" { return builtin_gt(args, loc, env) }
    if name == "<=" { return builtin_le(args, loc, env) }
    if name == ">=" { return builtin_ge(args, loc, env) }
    if name == "cons" { return builtin_cons(args, loc, env) }
    if name == "car" { return builtin_car(args, loc, env) }
    if name == "cdr" { return builtin_cdr(args, loc, env) }
    if name == "list" { return EvalOk(LispList(args, None), env) }
    if name == "null?" { return builtin_null(args, loc, env) }
    if name == "pair?" { return builtin_pair(args, loc, env) }
    if name == "length" { return builtin_length(args, loc, env) }
    if name == "number?" { return builtin_numberp(args, loc, env) }
    if name == "string?" { return builtin_stringp(args, loc, env) }
    if name == "symbol?" { return builtin_symbolp(args, loc, env) }
    if name == "procedure?" { return builtin_procedurep(args, loc, env) }
    if name == "boolean?" { return builtin_booleanp(args, loc, env) }
    if name == "eq?" { return builtin_eqp(args, loc, env) }
    if name == "equal?" { return builtin_equalp(args, loc, env) }
    if name == "not" { return builtin_not(args, loc, env) }
    if name == "string-append" { return builtin_string_append(args, loc, env) }
    if name == "string-length" { return builtin_string_length(args, loc, env) }
    if name == "number->string" { return builtin_num_to_str(args, loc, env) }
    if name == "string->number" { return builtin_str_to_num(args, loc, env) }
    if name == "string-ref" { return builtin_string_ref(args, loc, env) }
    if name == "substring" { return builtin_substring(args, loc, env) }
    if name == "string->list" { return builtin_string_to_list(args, loc, env) }
    if name == "list->string" { return builtin_list_to_string(args, loc, env) }
    if name == "char->integer" { return builtin_char_to_integer(args, loc, env) }
    if name == "integer->char" { return builtin_integer_to_char(args, loc, env) }
    if name == "string-split" { return builtin_string_split(args, loc, env) }
    if name == "string-join" { return builtin_string_join(args, loc, env) }
    if name == "abs" { return builtin_abs(args, loc, env) }
    if name == "min" { return builtin_min(args, loc, env) }
    if name == "max" { return builtin_max(args, loc, env) }
    if name == "display" { return builtin_display(args, loc, env) }
    if name == "newline" { return builtin_newline(args, loc, env) }
    if name == "read-line" { return builtin_read_line(args, loc, env) }
    // Test framework builtins
    // Note: assert-throws is a special form (in eval_list), not a builtin
    if name == "assert-eq" { return builtin_assert_eq(args, loc, env) }
    if name == "assert-true" { return builtin_assert_true(args, loc, env) }
    if name == "assert-false" { return builtin_assert_false(args, loc, env) }
    if name == "test-begin" { return builtin_test_begin(args, loc, env) }
    if name == "test-end" { return builtin_test_end(args, loc, env) }
    if name == "test-summary" { return builtin_test_summary(args, loc, env) }
    if name == "test-reset" { return builtin_test_reset(args, loc, env) }
    // LSP support builtins
    if name == "check-syntax" { return builtin_check_syntax(args, loc, env) }
    return EvalErr("Unknown builtin: " + name, loc)
}

effect fn builtin_display(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(v, Nil) => {
            match v {
                LispString(s) => { std.io.print(s) }
                _ => { std.io.print(lisp_to_string(v)) }
            }
            return EvalOk(LispNil, env)
        }
        _ => { return EvalErr("display: requires one argument", loc) }
    }
}

effect fn builtin_newline(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    std.io.println("")
    return EvalOk(LispNil, env)
}

effect fn builtin_read_line(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Nil => {
            match std.io.read_line() {
                Ok(line) => { return EvalOk(LispString(line), env) }
                Err(_) => { return EvalOk(LispBool(false), env) }
            }
        }
        _ => { return EvalErr("read-line: takes no arguments", loc) }
    }
}

// ============================================================================
// Test Framework Builtins
// ============================================================================

// Helper to get test counter from environment
fn get_test_count(env: Env, name: string) -> i64 {
    match env_lookup(env, name) {
        Some(LispInt(n)) => { return n }
        _ => { return 0i64 }
    }
}

// Helper to increment a test counter in the environment
fn inc_test_count(env: Env, name: string) -> Env {
    let current: i64 = get_test_count(env, name)
    return env_define(env, name, LispInt(current + 1i64))
}

effect fn builtin_assert_eq(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(expected, Cons(actual, rest)) => {
            var desc: string = "assertion"
            match rest {
                Cons(first_rest, Nil) => {
                    match first_rest {
                        LispString(s) => { desc = s }
                        _ => { return EvalErr("assert-eq: third argument must be a string description", loc) }
                    }
                }
                Nil => { }
                _ => { return EvalErr("assert-eq: too many arguments", loc) }
            }
            var new_env: Env = inc_test_count(env, "__test_count__")
            if values_equal(expected, actual) {
                new_env = inc_test_count(new_env, "__pass_count__")
                std.io.println("  PASS: " + desc)
                return EvalOk(LispBool(true), new_env)
            } else {
                new_env = inc_test_count(new_env, "__fail_count__")
                std.io.println("  FAIL: " + desc)
                std.io.println("    Expected: " + lisp_to_string(expected))
                std.io.println("    Actual:   " + lisp_to_string(actual))
                return EvalOk(LispBool(false), new_env)
            }
        }
        _ => { return EvalErr("assert-eq: requires two or three arguments (expected, actual, [description])", loc) }
    }
}

effect fn builtin_assert_true(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(value, rest) => {
            var desc: string = "assertion"
            match rest {
                Cons(first_rest, Nil) => {
                    match first_rest {
                        LispString(s) => { desc = s }
                        _ => { return EvalErr("assert-true: second argument must be a string description", loc) }
                    }
                }
                Nil => { }
                _ => { return EvalErr("assert-true: too many arguments", loc) }
            }
            var new_env: Env = inc_test_count(env, "__test_count__")
            if is_truthy(value) {
                new_env = inc_test_count(new_env, "__pass_count__")
                std.io.println("  PASS: " + desc)
                return EvalOk(LispBool(true), new_env)
            } else {
                new_env = inc_test_count(new_env, "__fail_count__")
                std.io.println("  FAIL: " + desc)
                std.io.println("    Expected: #t")
                std.io.println("    Actual:   " + lisp_to_string(value))
                return EvalOk(LispBool(false), new_env)
            }
        }
        _ => { return EvalErr("assert-true: requires one or two arguments (value, [description])", loc) }
    }
}

effect fn builtin_assert_false(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(value, rest) => {
            var desc: string = "assertion"
            match rest {
                Cons(first_rest, Nil) => {
                    match first_rest {
                        LispString(s) => { desc = s }
                        _ => { return EvalErr("assert-false: second argument must be a string description", loc) }
                    }
                }
                Nil => { }
                _ => { return EvalErr("assert-false: too many arguments", loc) }
            }
            var new_env: Env = inc_test_count(env, "__test_count__")
            if not is_truthy(value) {
                new_env = inc_test_count(new_env, "__pass_count__")
                std.io.println("  PASS: " + desc)
                return EvalOk(LispBool(true), new_env)
            } else {
                new_env = inc_test_count(new_env, "__fail_count__")
                std.io.println("  FAIL: " + desc)
                std.io.println("    Expected: #f")
                std.io.println("    Actual:   " + lisp_to_string(value))
                return EvalOk(LispBool(false), new_env)
            }
        }
        _ => { return EvalErr("assert-false: requires one or two arguments (value, [description])", loc) }
    }
}

effect fn builtin_test_begin(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(first, Nil) => {
            match first {
                LispString(name) => {
                    std.io.println("")
                    std.io.println("--- " + name + " ---")
                    return EvalOk(LispNil, env)
                }
                _ => { return EvalErr("test-begin: requires a string argument (test name)", loc) }
            }
        }
        _ => { return EvalErr("test-begin: requires exactly one string argument", loc) }
    }
}

effect fn builtin_test_end(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    return EvalOk(LispNil, env)
}

effect fn builtin_test_summary(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    let total: i64 = get_test_count(env, "__test_count__")
    let passed: i64 = get_test_count(env, "__pass_count__")
    let failed: i64 = get_test_count(env, "__fail_count__")
    std.io.println("")
    std.io.println("===================")
    std.io.println("Total: " + std.string.from_i64(total) + " | Passed: " + std.string.from_i64(passed) + " | Failed: " + std.string.from_i64(failed))
    if failed == 0i64 {
        std.io.println("All tests passed!")
        return EvalOk(LispBool(true), env)
    } else {
        std.io.println("Some tests failed.")
        return EvalOk(LispBool(false), env)
    }
}

effect fn builtin_test_reset(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    var new_env: Env = env_define(env, "__test_count__", LispInt(0i64))
    new_env = env_define(new_env, "__pass_count__", LispInt(0i64))
    new_env = env_define(new_env, "__fail_count__", LispInt(0i64))
    return EvalOk(LispNil, new_env)
}

// ============================================================================
// LSP Support Builtins
// ============================================================================

// Helper to build syntax error result
fn make_syntax_error_result(err_msg: string, err_loc_opt: Option[SourceLoc], env: Env) -> EvalResult {
    match err_loc_opt {
        Some(err_loc) => {
            // Use implicit i32 -> i64 widening
            let line_i64: i64 = err_loc.line
            let col_i64: i64 = err_loc.column
            let line_val: LispValue = LispInt(line_i64)
            let col_val: LispValue = LispInt(col_i64)
            let msg_val: LispValue = LispString(err_msg)
            let err_entry: LispValue = LispList(Cons(line_val, Cons(col_val, Cons(msg_val, Nil))), None)
            return EvalOk(LispList(Cons(err_entry, Nil), None), env)
        }
        None => {
            let line_val: LispValue = LispInt(1i64)
            let col_val: LispValue = LispInt(1i64)
            let msg_val: LispValue = LispString(err_msg)
            let err_entry: LispValue = LispList(Cons(line_val, Cons(col_val, Cons(msg_val, Nil))), None)
            return EvalOk(LispList(Cons(err_entry, Nil), None), env)
        }
    }
}

// check-syntax: Parse Lisp code and return syntax errors
// (check-syntax code-string) => () if valid, or ((line col message) ...) if errors
effect fn builtin_check_syntax(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(code), Nil) => {
            // Lex the code
            match tokenize(code, "<check>") {
                LexErr(lex_msg, err_loc) => {
                    // Return list with one error: ((line col message))
                    return make_syntax_error_result(lex_msg, Some(err_loc), env)
                }
                LexOk(tokens) => {
                    // Parse all expressions
                    match parse_all(tokens) {
                        ParseAllErr(parse_msg, err_loc_opt) => {
                            // Return list with one error
                            return make_syntax_error_result(parse_msg, err_loc_opt, env)
                        }
                        ParseAllOk(_) => {
                            // No errors - return empty list
                            return EvalOk(LispNil, env)
                        }
                    }
                }
            }
        }
        _ => { return EvalErr("check-syntax: requires one string argument", loc) }
    }
}

fn builtin_add(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    var sum_int: i64 = 0i64
    var sum_float: f64 = 0.0
    var is_float: bool = false
    for arg in args {
        match arg {
            LispInt(n) => { if is_float { sum_float = sum_float + to_float(n) } else { sum_int = sum_int + n } }
            LispFloat(n) => {
                if not is_float {
                    is_float = true
                    sum_float = to_float(sum_int)
                }
                sum_float = sum_float + n
            }
            _ => { return EvalErr("+: expected number", loc) }
        }
    }
    if is_float { return EvalOk(LispFloat(sum_float), env) } else { return EvalOk(LispInt(sum_int), env) }
}

fn builtin_sub(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Nil => { return EvalErr("-: requires arguments", loc) }
        Cons(first, rest) => {
            match first {
                LispInt(n) => {
                    match rest {
                        Nil => { return EvalOk(LispInt(0i64 - n), env) }
                        _ => {
                            var result: i64 = n
                            for arg in rest {
                                match arg {
                                    LispInt(m) => { result = result - m }
                                    _ => { return EvalErr("-: expected number", loc) }
                                }
                            }
                            return EvalOk(LispInt(result), env)
                        }
                    }
                }
                LispFloat(n) => {
                    match rest {
                        Nil => { return EvalOk(LispFloat(0.0 - n), env) }
                        _ => {
                            var result: f64 = n
                            for arg in rest {
                                match arg {
                                    LispFloat(m) => { result = result - m }
                                    LispInt(m) => { result = result - to_float(m) }
                                    _ => { return EvalErr("-: expected number", loc) }
                                }
                            }
                            return EvalOk(LispFloat(result), env)
                        }
                    }
                }
                _ => { return EvalErr("-: expected number", loc) }
            }
        }
    }
}

fn builtin_mul(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    var prod_int: i64 = 1i64
    var prod_float: f64 = 1.0
    var is_float: bool = false
    for arg in args {
        match arg {
            LispInt(n) => { if is_float { prod_float = prod_float * to_float(n) } else { prod_int = prod_int * n } }
            LispFloat(n) => {
                if not is_float {
                    is_float = true
                    prod_float = to_float(prod_int)
                }
                prod_float = prod_float * n
            }
            _ => { return EvalErr("*: expected number", loc) }
        }
    }
    if is_float { return EvalOk(LispFloat(prod_float), env) } else { return EvalOk(LispInt(prod_int), env) }
}

fn builtin_div(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return EvalErr("/: division by zero", loc) }
            return EvalOk(LispInt(a / b), env)
        }
        _ => { return EvalErr("/: requires two integer arguments", loc) }
    }
}

fn builtin_mod(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return EvalErr("mod: division by zero", loc) }
            return EvalOk(LispInt(a % b), env)
        }
        _ => { return EvalErr("mod: requires two integers", loc) }
    }
}

fn builtin_num_eq(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a == b), env) }
        Cons(LispFloat(a), Cons(LispFloat(b), Nil)) => { return EvalOk(LispBool(a == b), env) }
        _ => { return EvalErr("=: requires two numbers", loc) }
    }
}

fn builtin_lt(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a < b), env) }
        _ => { return EvalErr("<: requires two numbers", loc) }
    }
}

fn builtin_gt(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a > b), env) }
        _ => { return EvalErr(">: requires two numbers", loc) }
    }
}

fn builtin_le(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a <= b), env) }
        _ => { return EvalErr("<=: requires two numbers", loc) }
    }
}

fn builtin_ge(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return EvalOk(LispBool(a >= b), env) }
        _ => { return EvalErr(">=: requires two numbers", loc) }
    }
}

fn builtin_cons(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(head, Cons(LispList(tail, _), Nil)) => { return EvalOk(LispList(Cons(head, tail), None), env) }
        Cons(head, Cons(LispNil, Nil)) => { return EvalOk(LispList(Cons(head, Nil), None), env) }
        _ => { return EvalErr("cons: requires element and list", loc) }
    }
}

fn builtin_car(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Cons(head, _), _), Nil) => { return EvalOk(head, env) }
        _ => { return EvalErr("car: requires non-empty list", loc) }
    }
}

fn builtin_cdr(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Cons(_, tail), _), Nil) => { return EvalOk(LispList(tail, None), env) }
        _ => { return EvalErr("cdr: requires non-empty list", loc) }
    }
}

fn builtin_null(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Nil, _), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(LispNil, Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("null?: requires one argument", loc) }
    }
}

fn builtin_pair(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(Cons(_, _), _), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("pair?: requires one argument", loc) }
    }
}

fn builtin_length(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispList(items, _), Nil) => { return EvalOk(LispInt(std.list.length(items)), env) }
        Cons(LispNil, Nil) => { return EvalOk(LispInt(0i64), env) }
        _ => { return EvalErr("length: requires a list", loc) }
    }
}

fn builtin_numberp(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(LispFloat(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("number?: requires one argument", loc) }
    }
}

fn builtin_stringp(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("string?: requires one argument", loc) }
    }
}

fn builtin_symbolp(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispSymbol(_, _), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("symbol?: requires one argument", loc) }
    }
}

fn builtin_procedurep(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispLambda(_, _, _), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(LispBuiltin(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("procedure?: requires one argument", loc) }
    }
}

fn builtin_booleanp(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispBool(_), Nil) => { return EvalOk(LispBool(true), env) }
        Cons(_, Nil) => { return EvalOk(LispBool(false), env) }
        _ => { return EvalErr("boolean?: requires one argument", loc) }
    }
}

fn values_eq(a: LispValue, b: LispValue) -> bool {
    match (a, b) {
        (LispNil, LispNil) => { return true }
        (LispBool(x), LispBool(y)) => { return x == y }
        (LispInt(x), LispInt(y)) => { return x == y }
        (LispSymbol(x, _), LispSymbol(y, _)) => { return x == y }
        (LispString(x), LispString(y)) => { return x == y }
        _ => { return false }
    }
}

fn builtin_eqp(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(a, Cons(b, Nil)) => { return EvalOk(LispBool(values_eq(a, b)), env) }
        _ => { return EvalErr("eq?: requires two arguments", loc) }
    }
}

fn values_equal(a: LispValue, b: LispValue) -> bool {
    match (a, b) {
        (LispNil, LispNil) => { return true }
        (LispBool(x), LispBool(y)) => { return x == y }
        (LispInt(x), LispInt(y)) => { return x == y }
        (LispFloat(x), LispFloat(y)) => { return x == y }
        (LispSymbol(x, _), LispSymbol(y, _)) => { return x == y }
        (LispString(x), LispString(y)) => { return x == y }
        (LispList(xs, _), LispList(ys, _)) => { return lists_equal(xs, ys) }
        _ => { return false }
    }
}

fn lists_equal(xs: List[LispValue], ys: List[LispValue]) -> bool {
    match (xs, ys) {
        (Nil, Nil) => { return true }
        (Cons(x, xr), Cons(y, yr)) => {
            if not values_equal(x, y) {
                return false
            }
            return lists_equal(xr, yr)
        }
        _ => { return false }
    }
}

fn builtin_equalp(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(a, Cons(b, Nil)) => { return EvalOk(LispBool(values_equal(a, b)), env) }
        _ => { return EvalErr("equal?: requires two arguments", loc) }
    }
}

fn builtin_not(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(v, Nil) => { return EvalOk(LispBool(not is_truthy(v)), env) }
        _ => { return EvalErr("not: requires one argument", loc) }
    }
}

fn builtin_string_append(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    var sb: StringBuilder = std.builder.new()
    for arg in args {
        match arg {
            LispString(s) => { sb = std.builder.append(sb, s) }
            _ => { return EvalErr("string-append: requires strings", loc) }
        }
    }
    return EvalOk(LispString(std.builder.build(sb)), env)
}

fn builtin_string_length(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Nil) => { return EvalOk(LispInt(std.string.length(s)), env) }
        _ => { return EvalErr("string-length: requires one string", loc) }
    }
}

fn builtin_num_to_str(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(n), Nil) => { return EvalOk(LispString(to_string(n)), env) }
        Cons(LispFloat(n), Nil) => { return EvalOk(LispString(to_string(n)), env) }
        _ => { return EvalErr("number->string: requires a number", loc) }
    }
}

fn builtin_str_to_num(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Nil) => {
            match std.string.parse_int(s) {
                Some(n) => { return EvalOk(LispInt(n), env) }
                None => {
                    match std.string.parse_float(s) {
                        Some(f) => { return EvalOk(LispFloat(f), env) }
                        None => { return EvalOk(LispBool(false), env) }
                    }
                }
            }
        }
        _ => { return EvalErr("string->number: requires a string", loc) }
    }
}

fn builtin_string_ref(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Cons(LispInt(idx), Nil)) => {
            if idx < 0i64 {
                return EvalOk(LispBool(false), env)
            }
            let idx_i32: i32 = idx
            match std.string.char_at(s, idx_i32) {
                Some(c) => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append_char(sb, c)
                    return EvalOk(LispString(std.builder.build(sb)), env)
                }
                None => { return EvalOk(LispBool(false), env) }
            }
        }
        _ => { return EvalErr("string-ref: requires a string and an integer index", loc) }
    }
}

fn builtin_substring(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Cons(LispInt(start), Cons(LispInt(end), Nil))) => {
            if start < 0i64 {
                return EvalOk(LispBool(false), env)
            }
            let len: i32 = std.string.length(s)
            let start_i32: i32 = start
            var end_i32: i32 = end
            if start_i32 > len {
                return EvalOk(LispBool(false), env)
            }
            if end_i32 > len {
                end_i32 = len
            }
            if start_i32 > end_i32 {
                return EvalOk(LispBool(false), env)
            }
            match std.string.substring(s, start_i32, end_i32) {
                Some(sub) => { return EvalOk(LispString(sub), env) }
                None => { return EvalOk(LispBool(false), env) }
            }
        }
        _ => { return EvalErr("substring: requires a string and two integer indices", loc) }
    }
}

fn builtin_string_to_list(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Nil) => {
            var result: List[LispValue] = Nil
            for c in std.string.chars(s) {
                var sb: StringBuilder = std.builder.new()
                sb = std.builder.append_char(sb, c)
                result = Cons(LispString(std.builder.build(sb)), result)
            }
            return EvalOk(LispList(lisp_reverse(result), None), env)
        }
        _ => { return EvalErr("string->list: requires a string", loc) }
    }
}

fn builtin_list_to_string(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(lst, Nil) => {
            var sb: StringBuilder = std.builder.new()
            var current: LispValue = lst
            loop {
                match current {
                    LispList(Nil, _) => { break }
                    LispList(Cons(LispString(s), rest), _) => {
                        sb = std.builder.append(sb, s)
                        current = LispList(rest, None)
                    }
                    LispList(Cons(_, _), _) => {
                        return EvalErr("list->string: list must contain only strings", loc)
                    }
                    LispNil => { break }
                    _ => { return EvalErr("list->string: requires a list of strings", loc) }
                }
            }
            return EvalOk(LispString(std.builder.build(sb)), env)
        }
        _ => { return EvalErr("list->string: requires a list", loc) }
    }
}

fn builtin_char_to_integer(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Nil) => {
            let len: i32 = std.string.length(s)
            if len != 1i32 {
                return EvalOk(LispBool(false), env)
            }
            match std.string.char_at(s, 0i32) {
                Some(c) => { return EvalOk(LispInt(std.char.to_i32(c)), env) }
                None => { return EvalOk(LispBool(false), env) }
            }
        }
        _ => { return EvalErr("char->integer: requires a single-character string", loc) }
    }
}

fn builtin_integer_to_char(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(n), Nil) => {
            let n_i32: i32 = n
            match std.char.from_i32(n_i32) {
                Some(c) => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append_char(sb, c)
                    return EvalOk(LispString(std.builder.build(sb)), env)
                }
                None => { return EvalOk(LispBool(false), env) }
            }
        }
        _ => { return EvalErr("integer->char: requires an integer", loc) }
    }
}

fn builtin_string_split(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispString(s), Cons(LispString(delim), Nil)) => {
            let slen: i32 = std.string.length(s)
            let dlen: i32 = std.string.length(delim)

            if slen == 0i32 {
                return EvalOk(LispList(Cons(LispString(""), Nil), None), env)
            }

            // Empty delimiter: split into individual characters
            if dlen == 0i32 {
                var result: List[LispValue] = Nil
                for c in std.string.chars(s) {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append_char(sb, c)
                    result = Cons(LispString(std.builder.build(sb)), result)
                }
                return EvalOk(LispList(lisp_reverse(result), None), env)
            }

            // Normal split
            var result: List[LispValue] = Nil
            var start: i32 = 0i32
            var i: i32 = 0i32

            loop {
                if i > slen - dlen {
                    break
                }
                match std.string.substring(s, i, i + dlen) {
                    Some(sub) => {
                        if sub == delim {
                            match std.string.substring(s, start, i) {
                                Some(part) => { result = Cons(LispString(part), result) }
                                None => {}
                            }
                            start = i + dlen
                            i = start
                        } else {
                            i = i + 1i32
                        }
                    }
                    None => { i = i + 1i32 }
                }
            }

            // Add the last part
            match std.string.substring(s, start, slen) {
                Some(part) => { result = Cons(LispString(part), result) }
                None => {}
            }

            return EvalOk(LispList(lisp_reverse(result), None), env)
        }
        _ => { return EvalErr("string-split: requires two strings", loc) }
    }
}

fn builtin_string_join(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(lst, Cons(LispString(delim), Nil)) => {
            var sb: StringBuilder = std.builder.new()
            var current: LispValue = lst
            var first: bool = true
            loop {
                match current {
                    LispList(Nil, _) => { break }
                    LispList(Cons(LispString(s), rest), _) => {
                        if not first {
                            sb = std.builder.append(sb, delim)
                        }
                        sb = std.builder.append(sb, s)
                        first = false
                        current = LispList(rest, None)
                    }
                    LispList(Cons(_, _), _) => {
                        return EvalErr("string-join: list must contain only strings", loc)
                    }
                    LispNil => { break }
                    _ => { return EvalErr("string-join: requires a list of strings", loc) }
                }
            }
            return EvalOk(LispString(std.builder.build(sb)), env)
        }
        _ => { return EvalErr("string-join: requires a list and a delimiter string", loc) }
    }
}

fn builtin_abs(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(n), Nil) => { if n < 0i64 { return EvalOk(LispInt(0i64 - n), env) } else { return EvalOk(LispInt(n), env) } }
        Cons(LispFloat(n), Nil) => { if n < 0.0 { return EvalOk(LispFloat(0.0 - n), env) } else { return EvalOk(LispFloat(n), env) } }
        _ => { return EvalErr("abs: requires a number", loc) }
    }
}

fn builtin_min(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a < b { return EvalOk(LispInt(a), env) } else { return EvalOk(LispInt(b), env) } }
        _ => { return EvalErr("min: requires two numbers", loc) }
    }
}

fn builtin_max(args: List[LispValue], loc: Option[SourceLoc], env: Env) -> EvalResult {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a > b { return EvalOk(LispInt(a), env) } else { return EvalOk(LispInt(b), env) } }
        _ => { return EvalErr("max: requires two numbers", loc) }
    }
}

// ============================================================================
// Initial Environment
// ============================================================================

fn make_initial_env() -> Env {
    var env: Env = env_new()
    env = env_define(env, "+", LispBuiltin("+"))
    env = env_define(env, "-", LispBuiltin("-"))
    env = env_define(env, "*", LispBuiltin("*"))
    env = env_define(env, "/", LispBuiltin("/"))
    env = env_define(env, "mod", LispBuiltin("mod"))
    env = env_define(env, "=", LispBuiltin("="))
    env = env_define(env, "<", LispBuiltin("<"))
    env = env_define(env, ">", LispBuiltin(">"))
    env = env_define(env, "<=", LispBuiltin("<="))
    env = env_define(env, ">=", LispBuiltin(">="))
    env = env_define(env, "cons", LispBuiltin("cons"))
    env = env_define(env, "car", LispBuiltin("car"))
    env = env_define(env, "cdr", LispBuiltin("cdr"))
    env = env_define(env, "list", LispBuiltin("list"))
    env = env_define(env, "null?", LispBuiltin("null?"))
    env = env_define(env, "pair?", LispBuiltin("pair?"))
    env = env_define(env, "length", LispBuiltin("length"))
    env = env_define(env, "number?", LispBuiltin("number?"))
    env = env_define(env, "string?", LispBuiltin("string?"))
    env = env_define(env, "symbol?", LispBuiltin("symbol?"))
    env = env_define(env, "procedure?", LispBuiltin("procedure?"))
    env = env_define(env, "boolean?", LispBuiltin("boolean?"))
    env = env_define(env, "eq?", LispBuiltin("eq?"))
    env = env_define(env, "equal?", LispBuiltin("equal?"))
    env = env_define(env, "not", LispBuiltin("not"))
    env = env_define(env, "string-append", LispBuiltin("string-append"))
    env = env_define(env, "string-length", LispBuiltin("string-length"))
    env = env_define(env, "number->string", LispBuiltin("number->string"))
    env = env_define(env, "string->number", LispBuiltin("string->number"))
    env = env_define(env, "string-ref", LispBuiltin("string-ref"))
    env = env_define(env, "substring", LispBuiltin("substring"))
    env = env_define(env, "string->list", LispBuiltin("string->list"))
    env = env_define(env, "list->string", LispBuiltin("list->string"))
    env = env_define(env, "char->integer", LispBuiltin("char->integer"))
    env = env_define(env, "integer->char", LispBuiltin("integer->char"))
    env = env_define(env, "string-split", LispBuiltin("string-split"))
    env = env_define(env, "string-join", LispBuiltin("string-join"))
    env = env_define(env, "abs", LispBuiltin("abs"))
    env = env_define(env, "min", LispBuiltin("min"))
    env = env_define(env, "max", LispBuiltin("max"))
    env = env_define(env, "display", LispBuiltin("display"))
    env = env_define(env, "newline", LispBuiltin("newline"))
    env = env_define(env, "read-line", LispBuiltin("read-line"))
    // Test framework builtins
    // Note: assert-throws is a special form (in eval_list), not a builtin
    env = env_define(env, "assert-eq", LispBuiltin("assert-eq"))
    env = env_define(env, "assert-true", LispBuiltin("assert-true"))
    env = env_define(env, "assert-false", LispBuiltin("assert-false"))
    env = env_define(env, "test-begin", LispBuiltin("test-begin"))
    env = env_define(env, "test-end", LispBuiltin("test-end"))
    env = env_define(env, "test-summary", LispBuiltin("test-summary"))
    env = env_define(env, "test-reset", LispBuiltin("test-reset"))
    // LSP support builtins
    env = env_define(env, "check-syntax", LispBuiltin("check-syntax"))
    return env
}

// ============================================================================
// Intermediate Representation (IR)
// ============================================================================

type IRExpr =
    | IRConst(LispValue)
    | IRVar(string)
    | IRIf(IRExpr, IRExpr, IRExpr)
    | IRLet(List[(string, IRExpr)], IRExpr)
    | IRLambda(List[string], IRExpr)
    | IRApp(IRExpr, List[IRExpr])
    | IRDefine(string, IRExpr)
    | IRBegin(List[IRExpr])
    | IRSet(string, IRExpr)
    | IRBuiltin(string, List[IRExpr])
    | IRQuote(LispValue)
    | IRAnd(List[IRExpr])
    | IROr(List[IRExpr])

type TransformResult =
    | TransformOk(IRExpr)
    | TransformErr(string)

type TransformListResult =
    | TransformListOk(List[IRExpr])
    | TransformListErr(string)

// ============================================================================
// AST to IR Transformation
// ============================================================================

// List of builtin function names
fn is_builtin_name(name: string) -> bool {
    return name == "+" or name == "-" or name == "*" or name == "/" or
           name == "mod" or name == "=" or name == "<" or name == ">" or
           name == "<=" or name == ">=" or name == "cons" or name == "car" or
           name == "cdr" or name == "list" or name == "null?" or name == "pair?" or
           name == "length" or name == "number?" or name == "string?" or
           name == "symbol?" or name == "procedure?" or name == "boolean?" or
           name == "eq?" or name == "equal?" or name == "not" or
           name == "string-append" or name == "string-length" or
           name == "number->string" or name == "string->number" or
           name == "string-ref" or name == "substring" or
           name == "string->list" or name == "list->string" or
           name == "char->integer" or name == "integer->char" or
           name == "string-split" or name == "string-join" or
           name == "abs" or name == "min" or name == "max" or
           name == "display" or name == "newline"
}

fn to_ir(expr: LispValue) -> TransformResult {
    match expr {
        LispNil => { return TransformOk(IRConst(LispNil)) }
        LispBool(b) => { return TransformOk(IRConst(LispBool(b))) }
        LispInt(n) => { return TransformOk(IRConst(LispInt(n))) }
        LispFloat(n) => { return TransformOk(IRConst(LispFloat(n))) }
        LispString(s) => { return TransformOk(IRConst(LispString(s))) }
        LispSymbol(name, _) => { return TransformOk(IRVar(name)) }
        LispList(items, _) => { return to_ir_list(items) }
        LispLambda(_, _, _) => { return TransformErr("Cannot transform runtime lambda to IR") }
        LispBuiltin(_) => { return TransformErr("Cannot transform builtin to IR") }
        LispMacro(_, _, _) => { return TransformErr("Cannot transform macro to IR") }
    }
}

fn to_ir_list(items: List[LispValue]) -> TransformResult {
    match items {
        Nil => { return TransformOk(IRConst(LispNil)) }
        Cons(first, rest) => {
            match first {
                LispSymbol(name, _) => {
                    if name == "quote" { return to_ir_quote(rest) }
                    if name == "if" { return to_ir_if(rest) }
                    if name == "define" { return to_ir_define(rest) }
                    if name == "lambda" { return to_ir_lambda(rest) }
                    if name == "let" { return to_ir_let(rest) }
                    if name == "begin" { return to_ir_begin(rest) }
                    if name == "set!" { return to_ir_set(rest) }
                    if name == "and" { return to_ir_and(rest) }
                    if name == "or" { return to_ir_or(rest) }
                    // Check if it's a builtin call
                    if is_builtin_name(name) {
                        return to_ir_builtin(name, rest)
                    }
                    // Regular function application
                    return to_ir_app(first, rest)
                }
                _ => { return to_ir_app(first, rest) }
            }
        }
    }
}

fn to_ir_quote(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(value, Nil) => { return TransformOk(IRQuote(value)) }
        _ => { return TransformErr("quote requires one argument") }
    }
}

fn to_ir_if(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(cond, Cons(then_expr, else_part)) => {
            match to_ir(cond) {
                TransformOk(ir_cond) => {
                    match to_ir(then_expr) {
                        TransformOk(ir_then) => {
                            match else_part {
                                Cons(else_expr, Nil) => {
                                    match to_ir(else_expr) {
                                        TransformOk(ir_else) => {
                                            return TransformOk(IRIf(ir_cond, ir_then, ir_else))
                                        }
                                        TransformErr(msg) => { return TransformErr(msg) }
                                    }
                                }
                                Nil => {
                                    return TransformOk(IRIf(ir_cond, ir_then, IRConst(LispNil)))
                                }
                                _ => { return TransformErr("if: too many arguments") }
                            }
                        }
                        TransformErr(msg) => { return TransformErr(msg) }
                    }
                }
                TransformErr(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("if requires 2-3 arguments") }
    }
}

fn to_ir_define(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispSymbol(name, _), Cons(value_expr, Nil)) => {
            match to_ir(value_expr) {
                TransformOk(ir_value) => { return TransformOk(IRDefine(name, ir_value)) }
                TransformErr(msg) => { return TransformErr(msg) }
            }
        }
        Cons(LispList(name_and_params, _), body) => {
            // (define (name params...) body...) => (define name (lambda (params...) body...))
            match name_and_params {
                Cons(LispSymbol(name, _), params) => {
                    match extract_param_names(params) {
                        Ok(param_names) => {
                            let lambda_body: LispValue = make_begin(body)
                            match to_ir(lambda_body) {
                                TransformOk(ir_body) => {
                                    return TransformOk(IRDefine(name, IRLambda(param_names, ir_body)))
                                }
                                TransformErr(msg) => { return TransformErr(msg) }
                            }
                        }
                        Err(msg) => { return TransformErr(msg) }
                    }
                }
                _ => { return TransformErr("define: invalid function definition") }
            }
        }
        _ => { return TransformErr("define: invalid syntax") }
    }
}

fn to_ir_lambda(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispList(params, _), body) => {
            match extract_param_names(params) {
                Ok(param_names) => {
                    let lambda_body: LispValue = make_begin(body)
                    match to_ir(lambda_body) {
                        TransformOk(ir_body) => { return TransformOk(IRLambda(param_names, ir_body)) }
                        TransformErr(msg) => { return TransformErr(msg) }
                    }
                }
                Err(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("lambda: invalid syntax") }
    }
}

fn to_ir_let(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispList(bindings, _), body) => {
            match to_ir_let_bindings(bindings) {
                TransformListOk(ir_bindings_flat) => {
                    let lambda_body: LispValue = make_begin(body)
                    match to_ir(lambda_body) {
                        TransformOk(ir_body) => {
                            // Reconstruct binding pairs from flat list
                            let binding_pairs: List[(string, IRExpr)] = reconstruct_bindings(bindings, ir_bindings_flat)
                            return TransformOk(IRLet(binding_pairs, ir_body))
                        }
                        TransformErr(msg) => { return TransformErr(msg) }
                    }
                }
                TransformListErr(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("let: invalid syntax") }
    }
}

fn to_ir_let_bindings(bindings: List[LispValue]) -> TransformListResult {
    var ir_exprs: List[IRExpr] = Nil
    for binding in bindings {
        match binding {
            LispList(Cons(LispSymbol(_, _), Cons(value_expr, Nil)), _) => {
                match to_ir(value_expr) {
                    TransformOk(ir_value) => { ir_exprs = Cons(ir_value, ir_exprs) }
                    TransformErr(msg) => { return TransformListErr(msg) }
                }
            }
            _ => { return TransformListErr("let: invalid binding") }
        }
    }
    return TransformListOk(std.list.reverse(ir_exprs))
}

fn reconstruct_bindings(bindings: List[LispValue], ir_exprs: List[IRExpr]) -> List[(string, IRExpr)] {
    var result: List[(string, IRExpr)] = Nil
    var bind_iter: List[LispValue] = bindings
    var ir_iter: List[IRExpr] = ir_exprs
    loop {
        match (bind_iter, ir_iter) {
            (Cons(LispList(Cons(LispSymbol(name, _), _), _), rest_binds), Cons(ir_val, rest_irs)) => {
                result = Cons((name, ir_val), result)
                bind_iter = rest_binds
                ir_iter = rest_irs
            }
            _ => { break }
        }
    }
    return std.list.reverse(result)
}

fn to_ir_begin(args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_exprs) => { return TransformOk(IRBegin(ir_exprs)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_set(args: List[LispValue]) -> TransformResult {
    match args {
        Cons(LispSymbol(name, _), Cons(value_expr, Nil)) => {
            match to_ir(value_expr) {
                TransformOk(ir_value) => { return TransformOk(IRSet(name, ir_value)) }
                TransformErr(msg) => { return TransformErr(msg) }
            }
        }
        _ => { return TransformErr("set! requires variable and value") }
    }
}

fn to_ir_and(args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_exprs) => { return TransformOk(IRAnd(ir_exprs)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_or(args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_exprs) => { return TransformOk(IROr(ir_exprs)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_builtin(name: string, args: List[LispValue]) -> TransformResult {
    match to_ir_list_exprs(args) {
        TransformListOk(ir_args) => { return TransformOk(IRBuiltin(name, ir_args)) }
        TransformListErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_app(func: LispValue, args: List[LispValue]) -> TransformResult {
    match to_ir(func) {
        TransformOk(ir_func) => {
            match to_ir_list_exprs(args) {
                TransformListOk(ir_args) => { return TransformOk(IRApp(ir_func, ir_args)) }
                TransformListErr(msg) => { return TransformErr(msg) }
            }
        }
        TransformErr(msg) => { return TransformErr(msg) }
    }
}

fn to_ir_list_exprs(exprs: List[LispValue]) -> TransformListResult {
    var result: List[IRExpr] = Nil
    for expr in exprs {
        match to_ir(expr) {
            TransformOk(ir_expr) => { result = Cons(ir_expr, result) }
            TransformErr(msg) => { return TransformListErr(msg) }
        }
    }
    return TransformListOk(std.list.reverse(result))
}

fn to_ir_program(exprs: List[LispValue]) -> TransformListResult {
    return to_ir_list_exprs(exprs)
}

// ============================================================================
// Code Generator (IR -> Kira Source)
// ============================================================================

// Counter for generating unique variable names
type CodegenState = { counter: i64 }

fn codegen_fresh_var(state: CodegenState) -> (CodegenState, string) {
    let new_state: CodegenState = CodegenState { counter: state.counter + 1i64 }
    return (new_state, "_v" + to_string(state.counter))
}

fn escape_string(s: string) -> string {
    var sb: StringBuilder = std.builder.new()
    let len: i32 = std.string.length(s)
    var i: i32 = 0
    while i < len {
        let c: char = char_at(s, i)
        if c == '\n' {
            sb = std.builder.append(sb, "\\n")
        } else if c == '\t' {
            sb = std.builder.append(sb, "\\t")
        } else if c == '\r' {
            sb = std.builder.append(sb, "\\r")
        } else if c == '\\' {
            sb = std.builder.append(sb, "\\\\")
        } else if c == '"' {
            sb = std.builder.append(sb, "\\\"")
        } else {
            sb = std.builder.append_char(sb, c)
        }
        i = i + 1
    }
    return std.builder.build(sb)
}

// Convert a Kira identifier to a valid Kira identifier
fn mangle_name(name: string) -> string {
    var sb: StringBuilder = std.builder.new()
    let len: i32 = std.string.length(name)
    var i: i32 = 0
    while i < len {
        let c: char = char_at(name, i)
        if c == '-' {
            sb = std.builder.append(sb, "_")
        } else if c == '?' {
            sb = std.builder.append(sb, "_p")
        } else if c == '!' {
            sb = std.builder.append(sb, "_bang")
        } else if c == '+' {
            sb = std.builder.append(sb, "_plus")
        } else if c == '*' {
            sb = std.builder.append(sb, "_star")
        } else if c == '/' {
            sb = std.builder.append(sb, "_slash")
        } else if c == '<' {
            sb = std.builder.append(sb, "_lt")
        } else if c == '>' {
            sb = std.builder.append(sb, "_gt")
        } else if c == '=' {
            sb = std.builder.append(sb, "_eq")
        } else if c == '>' {
            sb = std.builder.append(sb, "_gt")
        } else {
            sb = std.builder.append_char(sb, c)
        }
        i = i + 1
    }
    return std.builder.build(sb)
}

fn codegen_lisp_value(v: LispValue) -> string {
    match v {
        LispNil => { return "LispNil" }
        LispBool(b) => {
            if b { return "LispBool(true)" } else { return "LispBool(false)" }
        }
        LispInt(n) => { return "LispInt(" + to_string(n) + "i64)" }
        LispFloat(n) => { return "LispFloat(" + to_string(n) + ")" }
        LispString(s) => { return "LispString(\"" + escape_string(s) + "\")" }
        LispSymbol(s, _) => { return "LispSymbol(\"" + escape_string(s) + "\")" }
        LispList(items, _) => {
            return "LispList(" + codegen_list_items(items) + ")"
        }
        LispLambda(_, _, _) => { return "LispNil" }  // Can't serialize closures
        LispBuiltin(n) => { return "LispBuiltin(\"" + n + "\")" }
        LispMacro(_, _, _) => { return "LispNil" }  // Can't serialize macros
    }
}

fn codegen_list_items(items: List[LispValue]) -> string {
    match items {
        Nil => { return "Nil" }
        Cons(head, tail) => {
            return "Cons(" + codegen_lisp_value(head) + ", " + codegen_list_items(tail) + ")"
        }
    }
}

fn codegen_expr(ir: IRExpr) -> string {
    match ir {
        IRConst(v) => { return codegen_lisp_value(v) }
        IRVar(name) => { return mangle_name(name) }
        IRQuote(v) => { return codegen_lisp_value(v) }
        IRIf(cond, then_expr, else_expr) => {
            return "if is_truthy(" + codegen_expr(cond) + ") { " +
                   codegen_expr(then_expr) + " } else { " +
                   codegen_expr(else_expr) + " }"
        }
        IRLet(bindings, body) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "{ ")
            for binding in bindings {
                let (name, value): (string, IRExpr) = binding
                sb = std.builder.append(sb, "let ")
                sb = std.builder.append(sb, mangle_name(name))
                sb = std.builder.append(sb, ": LispValue = ")
                sb = std.builder.append(sb, codegen_expr(value))
                sb = std.builder.append(sb, "; ")
            }
            sb = std.builder.append(sb, codegen_expr(body))
            sb = std.builder.append(sb, " }")
            return std.builder.build(sb)
        }
        IRLambda(params, body) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "fn(")
            var first: bool = true
            for p in params {
                if not first { sb = std.builder.append(sb, ", ") }
                sb = std.builder.append(sb, mangle_name(p))
                sb = std.builder.append(sb, ": LispValue")
                first = false
            }
            sb = std.builder.append(sb, ") -> LispValue { ")
            sb = std.builder.append(sb, codegen_expr(body))
            sb = std.builder.append(sb, " }")
            return std.builder.build(sb)
        }
        IRApp(func, args) => {
            // If func is a variable reference, call it directly (since we compile functions to Kira fns)
            match func {
                IRVar(name) => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, mangle_name(name))
                    sb = std.builder.append(sb, "(")
                    var first: bool = true
                    for arg in args {
                        if not first { sb = std.builder.append(sb, ", ") }
                        sb = std.builder.append(sb, codegen_expr(arg))
                        first = false
                    }
                    sb = std.builder.append(sb, ")")
                    return std.builder.build(sb)
                }
                _ => {
                    // For lambda expressions or other complex callees, we'd need LispFunc
                    // For now, just generate a direct call (won't work for lambdas)
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, "/* complex callee */ (")
                    sb = std.builder.append(sb, codegen_expr(func))
                    sb = std.builder.append(sb, ")(")
                    var first: bool = true
                    for arg in args {
                        if not first { sb = std.builder.append(sb, ", ") }
                        sb = std.builder.append(sb, codegen_expr(arg))
                        first = false
                    }
                    sb = std.builder.append(sb, ")")
                    return std.builder.build(sb)
                }
            }
        }
        IRDefine(name, value) => {
            // Definitions are handled at top-level
            return "/* define " + name + " */"
        }
        IRBegin(exprs) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, "{ ")
            var result_var: string = "_result"
            sb = std.builder.append(sb, "var ")
            sb = std.builder.append(sb, result_var)
            sb = std.builder.append(sb, ": LispValue = LispNil; ")
            for expr in exprs {
                sb = std.builder.append(sb, result_var)
                sb = std.builder.append(sb, " = ")
                sb = std.builder.append(sb, codegen_expr(expr))
                sb = std.builder.append(sb, "; ")
            }
            sb = std.builder.append(sb, result_var)
            sb = std.builder.append(sb, " }")
            return std.builder.build(sb)
        }
        IRSet(name, value) => {
            return "{ " + mangle_name(name) + " = " + codegen_expr(value) + "; LispNil }"
        }
        IRBuiltin(name, args) => {
            return codegen_builtin_call(name, args)
        }
        IRAnd(exprs) => {
            match exprs {
                Nil => { return "LispBool(true)" }
                Cons(single, Nil) => { return codegen_expr(single) }
                _ => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, "{ var _and_result: LispValue = LispBool(true); ")
                    for expr in exprs {
                        sb = std.builder.append(sb, "_and_result = ")
                        sb = std.builder.append(sb, codegen_expr(expr))
                        sb = std.builder.append(sb, "; if not is_truthy(_and_result) { _and_result } else { ")
                    }
                    sb = std.builder.append(sb, "_and_result")
                    for _ in exprs {
                        sb = std.builder.append(sb, " }")
                    }
                    sb = std.builder.append(sb, " }")
                    return std.builder.build(sb)
                }
            }
        }
        IROr(exprs) => {
            match exprs {
                Nil => { return "LispBool(false)" }
                Cons(single, Nil) => { return codegen_expr(single) }
                _ => {
                    var sb: StringBuilder = std.builder.new()
                    sb = std.builder.append(sb, "{ var _or_result: LispValue = LispBool(false); ")
                    for expr in exprs {
                        sb = std.builder.append(sb, "_or_result = ")
                        sb = std.builder.append(sb, codegen_expr(expr))
                        sb = std.builder.append(sb, "; if is_truthy(_or_result) { _or_result } else { ")
                    }
                    sb = std.builder.append(sb, "_or_result")
                    for _ in exprs {
                        sb = std.builder.append(sb, " }")
                    }
                    sb = std.builder.append(sb, " }")
                    return std.builder.build(sb)
                }
            }
        }
    }
}

fn codegen_args_list(args: List[IRExpr]) -> string {
    match args {
        Nil => { return "Nil" }
        Cons(arg, rest) => {
            return "Cons(" + codegen_expr(arg) + ", " + codegen_args_list(rest) + ")"
        }
    }
}

fn codegen_builtin_call(name: string, args: List[IRExpr]) -> string {
    // Generate inline code for builtins when possible
    if name == "+" {
        return "rt_add(" + codegen_args_list(args) + ")"
    }
    if name == "-" {
        return "rt_sub(" + codegen_args_list(args) + ")"
    }
    if name == "*" {
        return "rt_mul(" + codegen_args_list(args) + ")"
    }
    if name == "/" {
        return "rt_div(" + codegen_args_list(args) + ")"
    }
    if name == "mod" {
        return "rt_mod(" + codegen_args_list(args) + ")"
    }
    if name == "=" {
        return "rt_num_eq(" + codegen_args_list(args) + ")"
    }
    if name == "<" {
        return "rt_lt(" + codegen_args_list(args) + ")"
    }
    if name == ">" {
        return "rt_gt(" + codegen_args_list(args) + ")"
    }
    if name == "<=" {
        return "rt_le(" + codegen_args_list(args) + ")"
    }
    if name == ">=" {
        return "rt_ge(" + codegen_args_list(args) + ")"
    }
    if name == "cons" {
        return "rt_cons(" + codegen_args_list(args) + ")"
    }
    if name == "car" {
        return "rt_car(" + codegen_args_list(args) + ")"
    }
    if name == "cdr" {
        return "rt_cdr(" + codegen_args_list(args) + ")"
    }
    if name == "list" {
        return "LispList(" + codegen_args_list(args) + ")"
    }
    if name == "null?" {
        return "rt_null_p(" + codegen_args_list(args) + ")"
    }
    if name == "pair?" {
        return "rt_pair_p(" + codegen_args_list(args) + ")"
    }
    if name == "length" {
        return "rt_length(" + codegen_args_list(args) + ")"
    }
    if name == "not" {
        return "rt_not(" + codegen_args_list(args) + ")"
    }
    if name == "eq?" {
        return "rt_eq_p(" + codegen_args_list(args) + ")"
    }
    if name == "equal?" {
        return "rt_equal_p(" + codegen_args_list(args) + ")"
    }
    if name == "display" {
        return "rt_display(" + codegen_args_list(args) + ")"
    }
    if name == "newline" {
        return "rt_newline()"
    }
    if name == "number?" {
        return "rt_number_p(" + codegen_args_list(args) + ")"
    }
    if name == "string?" {
        return "rt_string_p(" + codegen_args_list(args) + ")"
    }
    if name == "symbol?" {
        return "rt_symbol_p(" + codegen_args_list(args) + ")"
    }
    if name == "procedure?" {
        return "rt_procedure_p(" + codegen_args_list(args) + ")"
    }
    if name == "boolean?" {
        return "rt_boolean_p(" + codegen_args_list(args) + ")"
    }
    if name == "string-append" {
        return "rt_string_append(" + codegen_args_list(args) + ")"
    }
    if name == "string-length" {
        return "rt_string_length(" + codegen_args_list(args) + ")"
    }
    if name == "number->string" {
        return "rt_number_to_string(" + codegen_args_list(args) + ")"
    }
    if name == "string->number" {
        return "rt_string_to_number(" + codegen_args_list(args) + ")"
    }
    if name == "abs" {
        return "rt_abs(" + codegen_args_list(args) + ")"
    }
    if name == "min" {
        return "rt_min(" + codegen_args_list(args) + ")"
    }
    if name == "max" {
        return "rt_max(" + codegen_args_list(args) + ")"
    }
    // Fallback: generic builtin call
    return "rt_call_builtin(\"" + name + "\", " + codegen_args_list(args) + ")"
}

// Collect top-level definitions
fn collect_definitions(ir_exprs: List[IRExpr]) -> (List[(string, IRExpr)], List[IRExpr]) {
    var defs: List[(string, IRExpr)] = Nil
    var others: List[IRExpr] = Nil
    for ir in ir_exprs {
        match ir {
            IRDefine(name, value) => { defs = Cons((name, value), defs) }
            _ => { others = Cons(ir, others) }
        }
    }
    return (std.list.reverse(defs), std.list.reverse(others))
}

// Generate the runtime library
fn generate_runtime() -> string {
    return "// Lisp Runtime Library (generated)

type LispValue =
    | LispNil
    | LispBool(bool)
    | LispInt(i64)
    | LispFloat(f64)
    | LispString(string)
    | LispSymbol(string)
    | LispList(List[LispValue])

fn is_truthy(v: LispValue) -> bool {
    match v { LispBool(b) => { return b } _ => { return true } }
}

fn lisp_to_string(v: LispValue) -> string {
    match v {
        LispNil => { return \"()\" }
        LispBool(b) => { if b { return \"#t\" } else { return \"#f\" } }
        LispInt(n) => { return to_string(n) }
        LispFloat(n) => { return to_string(n) }
        LispString(s) => { return \"\\\"\" + s + \"\\\"\" }
        LispSymbol(s) => { return s }
        LispList(items) => {
            var sb: StringBuilder = std.builder.new()
            sb = std.builder.append(sb, \"(\")
            var first: bool = true
            for item in items {
                if not first { sb = std.builder.append(sb, \" \") }
                sb = std.builder.append(sb, lisp_to_string(item))
                first = false
            }
            sb = std.builder.append(sb, \")\")
            return std.builder.build(sb)
        }
    }
}

fn rt_add(args: List[LispValue]) -> LispValue {
    var sum: i64 = 0i64
    for arg in args {
        match arg {
            LispInt(n) => { sum = sum + n }
            _ => { return LispNil }
        }
    }
    return LispInt(sum)
}

fn rt_sub(args: List[LispValue]) -> LispValue {
    match args {
        Nil => { return LispNil }
        Cons(LispInt(first), rest) => {
            match rest {
                Nil => { return LispInt(0i64 - first) }
                _ => {
                    var result: i64 = first
                    for arg in rest {
                        match arg {
                            LispInt(n) => { result = result - n }
                            _ => { return LispNil }
                        }
                    }
                    return LispInt(result)
                }
            }
        }
        _ => { return LispNil }
    }
}

fn rt_mul(args: List[LispValue]) -> LispValue {
    var prod: i64 = 1i64
    for arg in args {
        match arg {
            LispInt(n) => { prod = prod * n }
            _ => { return LispNil }
        }
    }
    return LispInt(prod)
}

fn rt_div(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return LispNil }
            return LispInt(a / b)
        }
        _ => { return LispNil }
    }
}

fn rt_mod(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => {
            if b == 0i64 { return LispNil }
            return LispInt(a % b)
        }
        _ => { return LispNil }
    }
}

fn rt_num_eq(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a == b) }
        _ => { return LispBool(false) }
    }
}

fn rt_lt(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a < b) }
        _ => { return LispBool(false) }
    }
}

fn rt_gt(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a > b) }
        _ => { return LispBool(false) }
    }
}

fn rt_le(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a <= b) }
        _ => { return LispBool(false) }
    }
}

fn rt_ge(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { return LispBool(a >= b) }
        _ => { return LispBool(false) }
    }
}

fn rt_cons(args: List[LispValue]) -> LispValue {
    match args {
        Cons(head, Cons(LispList(tail), Nil)) => { return LispList(Cons(head, tail)) }
        Cons(head, Cons(LispNil, Nil)) => { return LispList(Cons(head, Nil)) }
        _ => { return LispNil }
    }
}

fn rt_car(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Cons(head, _)), Nil) => { return head }
        _ => { return LispNil }
    }
}

fn rt_cdr(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Cons(_, tail)), Nil) => { return LispList(tail) }
        _ => { return LispNil }
    }
}

fn rt_null_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Nil), Nil) => { return LispBool(true) }
        Cons(LispNil, Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_pair_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(Cons(_, _)), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_length(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispList(items), Nil) => { return LispInt(std.list.length(items)) }
        Cons(LispNil, Nil) => { return LispInt(0i64) }
        _ => { return LispNil }
    }
}

fn rt_not(args: List[LispValue]) -> LispValue {
    match args {
        Cons(v, Nil) => { return LispBool(not is_truthy(v)) }
        _ => { return LispNil }
    }
}

fn rt_eq_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(a, Cons(b, Nil)) => {
            match (a, b) {
                (LispNil, LispNil) => { return LispBool(true) }
                (LispBool(x), LispBool(y)) => { return LispBool(x == y) }
                (LispInt(x), LispInt(y)) => { return LispBool(x == y) }
                (LispSymbol(x), LispSymbol(y)) => { return LispBool(x == y) }
                (LispString(x), LispString(y)) => { return LispBool(x == y) }
                _ => { return LispBool(false) }
            }
        }
        _ => { return LispBool(false) }
    }
}

fn lists_equal_rt(xs: List[LispValue], ys: List[LispValue]) -> bool {
    match (xs, ys) {
        (Nil, Nil) => { return true }
        (Cons(x, xr), Cons(y, yr)) => {
            if not values_equal_rt(x, y) { return false }
            return lists_equal_rt(xr, yr)
        }
        _ => { return false }
    }
}

fn values_equal_rt(a: LispValue, b: LispValue) -> bool {
    match (a, b) {
        (LispNil, LispNil) => { return true }
        (LispBool(x), LispBool(y)) => { return x == y }
        (LispInt(x), LispInt(y)) => { return x == y }
        (LispFloat(x), LispFloat(y)) => { return x == y }
        (LispSymbol(x), LispSymbol(y)) => { return x == y }
        (LispString(x), LispString(y)) => { return x == y }
        (LispList(xs), LispList(ys)) => { return lists_equal_rt(xs, ys) }
        _ => { return false }
    }
}

fn rt_equal_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(a, Cons(b, Nil)) => { return LispBool(values_equal_rt(a, b)) }
        _ => { return LispBool(false) }
    }
}

fn rt_number_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(_), Nil) => { return LispBool(true) }
        Cons(LispFloat(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_string_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispString(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_symbol_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispSymbol(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_procedure_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_boolean_p(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispBool(_), Nil) => { return LispBool(true) }
        Cons(_, Nil) => { return LispBool(false) }
        _ => { return LispBool(false) }
    }
}

fn rt_string_append(args: List[LispValue]) -> LispValue {
    var sb: StringBuilder = std.builder.new()
    for arg in args {
        match arg {
            LispString(s) => { sb = std.builder.append(sb, s) }
            _ => { return LispNil }
        }
    }
    return LispString(std.builder.build(sb))
}

fn rt_string_length(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispString(s), Nil) => { return LispInt(std.string.length(s)) }
        _ => { return LispNil }
    }
}

fn rt_number_to_string(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(n), Nil) => { return LispString(to_string(n)) }
        Cons(LispFloat(n), Nil) => { return LispString(to_string(n)) }
        _ => { return LispNil }
    }
}

fn rt_string_to_number(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispString(s), Nil) => {
            match std.string.parse_int(s) {
                Some(n) => { return LispInt(n) }
                None => {
                    match std.string.parse_float(s) {
                        Some(f) => { return LispFloat(f) }
                        None => { return LispBool(false) }
                    }
                }
            }
        }
        _ => { return LispNil }
    }
}

fn rt_abs(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(n), Nil) => { if n < 0i64 { return LispInt(0i64 - n) } else { return LispInt(n) } }
        Cons(LispFloat(n), Nil) => { if n < 0.0 { return LispFloat(0.0 - n) } else { return LispFloat(n) } }
        _ => { return LispNil }
    }
}

fn rt_min(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a < b { return LispInt(a) } else { return LispInt(b) } }
        _ => { return LispNil }
    }
}

fn rt_max(args: List[LispValue]) -> LispValue {
    match args {
        Cons(LispInt(a), Cons(LispInt(b), Nil)) => { if a > b { return LispInt(a) } else { return LispInt(b) } }
        _ => { return LispNil }
    }
}

effect fn rt_display(args: List[LispValue]) -> LispValue {
    match args {
        Cons(v, Nil) => {
            match v {
                LispString(s) => { std.io.print(s) }
                _ => { std.io.print(lisp_to_string(v)) }
            }
            return LispNil
        }
        _ => { return LispNil }
    }
}

effect fn rt_newline() -> LispValue {
    std.io.println(\"\")
    return LispNil
}

"
}

// Generate compiled Kira program
fn generate_program(ir_exprs: List[IRExpr]) -> string {
    var sb: StringBuilder = std.builder.new()

    // Add runtime
    sb = std.builder.append(sb, generate_runtime())

    // Separate definitions from other expressions
    let (defs, others): (List[(string, IRExpr)], List[IRExpr]) = collect_definitions(ir_exprs)

    // Generate global definitions
    sb = std.builder.append(sb, "// User-defined functions\n")
    for def in defs {
        let (name, value): (string, IRExpr) = def
        match value {
            IRLambda(params, body) => {
                // Generate as a named function
                sb = std.builder.append(sb, "fn ")
                sb = std.builder.append(sb, mangle_name(name))
                sb = std.builder.append(sb, "(")
                var first: bool = true
                for p in params {
                    if not first { sb = std.builder.append(sb, ", ") }
                    sb = std.builder.append(sb, mangle_name(p))
                    sb = std.builder.append(sb, ": LispValue")
                    first = false
                }
                sb = std.builder.append(sb, ") -> LispValue {\n    return ")
                sb = std.builder.append(sb, codegen_expr(body))
                sb = std.builder.append(sb, "\n}\n\n")
            }
            _ => {
                // Generate as a global variable
                sb = std.builder.append(sb, "var ")
                sb = std.builder.append(sb, mangle_name(name))
                sb = std.builder.append(sb, ": LispValue = ")
                sb = std.builder.append(sb, codegen_expr(value))
                sb = std.builder.append(sb, "\n\n")
            }
        }
    }

    // Generate main function with top-level expressions
    sb = std.builder.append(sb, "effect fn main() -> void {\n")
    for expr in others {
        sb = std.builder.append(sb, "    let _: LispValue = ")
        sb = std.builder.append(sb, codegen_expr(expr))
        sb = std.builder.append(sb, "\n")
    }
    sb = std.builder.append(sb, "}\n")

    return std.builder.build(sb)
}

// ============================================================================
// Compiler Entry Point
// ============================================================================

effect fn compile_file(input_path: string, output_path: string) -> void {
    match std.fs.read_file(input_path) {
        Ok(source) => {
            match tokenize(source, input_path) {
                LexOk(tokens) => {
                    match parse_all(tokens) {
                        ParseAllOk(exprs) => {
                            match to_ir_program(exprs) {
                                TransformListOk(ir_exprs) => {
                                    let output: string = generate_program(ir_exprs)
                                    match std.fs.write_file(output_path, output) {
                                        Ok(_) => {
                                            std.io.println("Compiled " + input_path + " to " + output_path)
                                        }
                                        Err(msg) => {
                                            std.io.println("Error writing output: " + msg)
                                        }
                                    }
                                }
                                TransformListErr(msg) => {
                                    std.io.println("Transform error: " + msg)
                                }
                            }
                        }
                        ParseAllErr(msg, _) => {
                            std.io.println("Parse error: " + msg)
                        }
                    }
                }
                LexErr(msg, loc) => {
                    std.io.println(format_error("Lex error: " + msg, Some(loc), source))
                }
            }
        }
        Err(msg) => {
            std.io.println("Error reading file: " + msg)
        }
    }
}

// ============================================================================
// Error Formatting
// ============================================================================

// Get a line from source by line number (1-indexed)
fn get_source_line(source: string, line_num: i32) -> string {
    let len: i32 = std.string.length(source)
    var current_line: i32 = 1
    var line_start: i32 = 0
    var i: i32 = 0

    // Find start of the requested line
    while i < len and current_line < line_num {
        if char_at(source, i) == '\n' {
            current_line = current_line + 1
            line_start = i + 1
        }
        i = i + 1
    }

    if current_line != line_num {
        return ""
    }

    // Find end of line
    var line_end: i32 = line_start
    while line_end < len and char_at(source, line_end) != '\n' {
        line_end = line_end + 1
    }

    return substr(source, line_start, line_end)
}

// Format error with source context
effect fn format_error(msg: string, loc: Option[SourceLoc], source: string) -> string {
    match loc {
        Some(l) => {
            var sb: StringBuilder = std.builder.new()

            // File:line:column: error: message
            sb = std.builder.append(sb, l.file)
            sb = std.builder.append(sb, ":")
            sb = std.builder.append(sb, to_string(l.line))
            sb = std.builder.append(sb, ":")
            sb = std.builder.append(sb, to_string(l.column))
            sb = std.builder.append(sb, ": error: ")
            sb = std.builder.append(sb, msg)
            sb = std.builder.append(sb, "\n")

            // Get source line
            let src_line: string = get_source_line(source, l.line)
            if std.string.length(src_line) > 0 {
                // Line number and source line
                let line_prefix: string = "  " + to_string(l.line) + " | "
                sb = std.builder.append(sb, line_prefix)
                sb = std.builder.append(sb, src_line)
                sb = std.builder.append(sb, "\n")

                // Caret line
                let prefix_len: i32 = std.string.length(line_prefix)
                var j: i32 = 0
                while j < prefix_len {
                    sb = std.builder.append(sb, " ")
                    j = j + 1
                }
                // Add spaces up to column position
                var k: i32 = 1
                while k < l.column {
                    sb = std.builder.append(sb, " ")
                    k = k + 1
                }
                sb = std.builder.append(sb, "^")
            }

            return std.builder.build(sb)
        }
        None => {
            return "error: " + msg
        }
    }
}

// ============================================================================
// REPL and Main
// ============================================================================

effect fn run_program(source: string, file: string, env: Env) -> EvalResult {
    match tokenize(source, file) {
        LexOk(tokens) => {
            match parse_all(tokens) {
                ParseAllOk(exprs) => {
                    // Use trampoline to get final result with TCO
                    return trampoline(eval_begin_list(exprs, env))
                }
                ParseAllErr(msg, loc) => { return EvalErr("Parse error: " + msg, loc) }
            }
        }
        LexErr(msg, loc) => { return EvalErr("Lex error: " + msg, Some(loc)) }
    }
}

effect fn print_result(v: LispValue) -> void {
    let s: string = lisp_to_string(v)
    std.io.println(s)
}

effect fn repl_loop(env: Env) -> void {
    var current_env: Env = env
    loop {
        std.io.print("lisp> ")
        match std.io.read_line() {
            Ok(line) => {
                let trimmed: string = std.string.trim(line)
                if trimmed == "" {
                    // Empty line, continue
                } else if trimmed == "(exit)" or trimmed == "(quit)" {
                    std.io.println("Goodbye!")
                    break
                } else {
                    match tokenize(trimmed, "<repl>") {
                        LexOk(tokens) => {
                            match parse_all(tokens) {
                                ParseAllOk(exprs) => {
                                    // Use trampoline for TCO
                                    match trampoline(eval_begin_list(exprs, current_env)) {
                                        EvalOk(result, new_env) => {
                                            print_result(result)
                                            current_env = new_env
                                        }
                                        EvalErr(msg, loc) => {
                                            std.io.println(format_error(msg, loc, trimmed))
                                        }
                                        TailCall(_, _, _) => {
                                            std.io.println("Internal error: trampoline returned TailCall")
                                        }
                                    }
                                }
                                ParseAllErr(msg, loc) => {
                                    std.io.println(format_error("Parse error: " + msg, loc, trimmed))
                                }
                            }
                        }
                        LexErr(msg, loc) => {
                            std.io.println(format_error("Lex error: " + msg, Some(loc), trimmed))
                        }
                    }
                }
            }
            Err(_) => {
                std.io.println("")
                break
            }
        }
    }
}

effect fn run_file(path: string) -> void {
    match std.fs.read_file(path) {
        Ok(content) => {
            let env: Env = make_initial_env()
            match run_program(content, path, env) {
                EvalOk(result, _) => {
                    print_result(result)
                }
                EvalErr(msg, loc) => {
                    std.io.println(format_error(msg, loc, content))
                }
                TailCall(_, _, _) => {
                    std.io.println("Internal error: trampoline returned TailCall")
                }
            }
        }
        Err(msg) => {
            std.io.println("Error reading file: " + msg)
        }
    }
}

fn replace_extension(path: string, new_ext: string) -> string {
    // Find the last '.' in the path
    let len: i32 = std.string.length(path)
    var dot_pos: i32 = -1
    var i: i32 = len - 1
    while i >= 0 {
        if char_at(path, i) == '.' {
            dot_pos = i
            break
        }
        if char_at(path, i) == '/' {
            break
        }
        i = i - 1
    }
    if dot_pos > 0 {
        return substr(path, 0, dot_pos) + new_ext
    } else {
        return path + new_ext
    }
}

fn print_usage() -> void {
    std.io.println("Usage: kira run src/main.ki [options]")
    std.io.println("")
    std.io.println("Options:")
    std.io.println("  (no args)           Start REPL")
    std.io.println("  run <file.lisp>     Run a Lisp file")
    std.io.println("  compile <file.lisp> Compile to Kira (output: <file>.ki)")
    std.io.println("  help                Show this help")
}

effect fn main() -> void {
    let args: List[string] = std.env.args()
    match args {
        Nil => {
            std.io.println("Kira Lisp Interpreter")
            std.io.println("Type (exit) or (quit) to exit")
            std.io.println("")
            let env: Env = make_initial_env()
            repl_loop(env)
        }
        Cons(cmd, cmd_args) => {
            if cmd == "help" {
                print_usage()
            } else if cmd == "run" {
                match cmd_args {
                    Cons(file, _) => { run_file(file) }
                    Nil => {
                        std.io.println("Error: run requires a file argument")
                        print_usage()
                    }
                }
            } else if cmd == "compile" {
                match cmd_args {
                    Cons(file, _) => {
                        let output: string = replace_extension(file, ".ki")
                        compile_file(file, output)
                    }
                    Nil => {
                        std.io.println("Error: compile requires a file argument")
                        print_usage()
                    }
                }
            } else {
                // Assume it's a file to run
                run_file(cmd)
            }
        }
    }
}
