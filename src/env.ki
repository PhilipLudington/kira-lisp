// Environment operations for variable bindings
// Task 3.1: Environment Operations

// Forward declare LispValue for use in Env
type LispValue =
    | LispNil
    | LispBool(bool)
    | LispInt(i64)
    | LispFloat(f64)
    | LispString(string)
    | LispSymbol(string)
    | LispList(List[LispValue])
    | LispLambda(List[string], LispValue, Env)
    | LispBuiltin(string)

// Environment type for variable bindings
type Env = {
    bindings: HashMap,
    parent: Option[Env]
}

// Create a new empty environment
fn env_new() -> Env {
    return Env {
        bindings: std.map.new(),
        parent: None
    }
}

// Create a child environment with given parent
fn env_extend(parent: Env) -> Env {
    return Env {
        bindings: std.map.new(),
        parent: Some(parent)
    }
}

// Define a new binding in the current environment
fn env_define(env: Env, name: string, value: LispValue) -> Env {
    let new_bindings: HashMap = std.map.put(env.bindings, name, value)
    return Env {
        bindings: new_bindings,
        parent: env.parent
    }
}

// Lookup a variable in the environment chain
fn env_lookup(env: Env, name: string) -> Option[LispValue] {
    match std.map.get(env.bindings, name) {
        Some(value) => { return Some(value) }
        None => {
            match env.parent {
                Some(parent) => { return env_lookup(parent, name) }
                None => { return None }
            }
        }
    }
}

// Set an existing binding (searches up the chain)
// Returns Ok with updated env if found, Err with message if not found
fn env_set(env: Env, name: string, value: LispValue) -> Result[Env, string] {
    if std.map.contains(env.bindings, name) {
        let new_bindings: HashMap = std.map.put(env.bindings, name, value)
        return Ok(Env {
            bindings: new_bindings,
            parent: env.parent
        })
    } else {
        match env.parent {
            Some(parent) => {
                match env_set(parent, name, value) {
                    Ok(new_parent) => {
                        return Ok(Env {
                            bindings: env.bindings,
                            parent: Some(new_parent)
                        })
                    }
                    Err(msg) => { return Err(msg) }
                }
            }
            None => {
                return Err("Undefined variable: " + name)
            }
        }
    }
}

// Define multiple bindings at once (for function parameters)
fn env_define_all(env: Env, names: List[string], values: List[LispValue]) -> Result[Env, string] {
    var current_env: Env = env
    var name_list: List[string] = names
    var value_list: List[LispValue] = values

    loop {
        match (name_list, value_list) {
            (Nil, Nil) => {
                return Ok(current_env)
            }
            (Cons(name, rest_names), Cons(value, rest_values)) => {
                current_env = env_define(current_env, name, value)
                name_list = rest_names
                value_list = rest_values
            }
            (Nil, Cons(_, _)) => {
                return Err("Too many arguments")
            }
            (Cons(_, _), Nil) => {
                return Err("Not enough arguments")
            }
        }
    }
}
