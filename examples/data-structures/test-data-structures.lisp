; Tests for pure functional data structures

(import "src/stdlib.lisp")
(import "examples/data-structures/alist.lisp")
(import "examples/data-structures/set.lisp")
(import "examples/data-structures/bst.lisp")
(import "examples/data-structures/heap.lisp")

; Define test helper functions upfront to avoid Kira closure bugs
(define double (lambda (x) (* x 2)))
(define even? (lambda (x) (= (mod x 2) 0)))
(define gt3? (lambda (x) (> x 3)))

(test-reset)

; ============================================================================
; Association List Tests
; ============================================================================

(test-begin "alist-basic")
(define a1 (alist-empty))
(assert-eq '() a1 "empty alist is nil")
(define a2 (alist-put a1 'x 10))
(assert-eq 10 (alist-get a2 'x) "get after put")
(assert-eq '() (alist-get a2 'y) "get missing key returns nil")
(define a3 (alist-put a2 'y 20))
(assert-eq 10 (alist-get a3 'x) "x still present")
(assert-eq 20 (alist-get a3 'y) "y is present")
(test-end)

(test-begin "alist-update")
(define a1 (alist-put (alist-empty) 'x 10))
(define a2 (alist-put a1 'x 99))
(assert-eq 99 (alist-get a2 'x) "update overwrites value")
(assert-eq 1 (alist-size a2) "size unchanged after update")
(test-end)

(test-begin "alist-remove")
(define a1 (alist-put (alist-put (alist-empty) 'x 10) 'y 20))
(define a2 (alist-remove a1 'x))
(assert-eq '() (alist-get a2 'x) "removed key returns nil")
(assert-eq 20 (alist-get a2 'y) "other key still present")
(assert-eq 1 (alist-size a2) "size decreased")
(define a3 (alist-remove a2 'z))
(assert-eq 1 (alist-size a3) "remove missing key is no-op")
(test-end)

(test-begin "alist-contains")
(define a1 (alist-put (alist-empty) 'x 10))
(assert-true (alist-contains? a1 'x) "contains existing key")
(assert-false (alist-contains? a1 'y) "does not contain missing key")
(test-end)

(test-begin "alist-get-or")
(define a1 (alist-put (alist-empty) 'x 10))
(assert-eq 10 (alist-get-or a1 'x 999) "get-or returns value if present")
(assert-eq 999 (alist-get-or a1 'y 999) "get-or returns default if missing")
(test-end)

(test-begin "alist-keys-values")
(define a1 (alist-put (alist-put (alist-empty) 'x 10) 'y 20))
(assert-eq 2 (length (alist-keys a1)) "two keys")
(assert-eq 2 (length (alist-values a1)) "two values")
(assert-true (member? 'x (alist-keys a1)) "x in keys")
(assert-true (member? 'y (alist-keys a1)) "y in keys")
(assert-true (member? 10 (alist-values a1)) "10 in values")
(assert-true (member? 20 (alist-values a1)) "20 in values")
(test-end)

(test-begin "alist-merge")
(define a1 (alist-put (alist-empty) 'x 10))
(define a2 (alist-put (alist-put (alist-empty) 'x 99) 'y 20))
(define merged (alist-merge a1 a2))
(assert-eq 99 (alist-get merged 'x) "merge: second wins on conflict")
(assert-eq 20 (alist-get merged 'y) "merge: includes second's unique keys")
(test-end)

(test-begin "alist-immutability")
(define a1 (alist-put (alist-empty) 'x 10))
(define a2 (alist-put a1 'y 20))
(assert-eq 1 (alist-size a1) "original unchanged after put")
(assert-false (alist-contains? a1 'y) "original does not have new key")
(test-end)

; ============================================================================
; Set Tests
; ============================================================================

(test-begin "set-basic")
(define s1 (set-empty))
(assert-eq '() s1 "empty set is nil")
(define s2 (set-add s1 5))
(assert-true (set-contains? s2 5) "contains added element")
(assert-false (set-contains? s2 3) "does not contain other element")
(test-end)

(test-begin "set-sorted")
(define s1 (set-add (set-add (set-add (set-empty) 3) 1) 2))
(assert-eq '(1 2 3) (set->list s1) "set is sorted")
(test-end)

(test-begin "set-unique")
(define s1 (set-add (set-add (set-empty) 5) 5))
(assert-eq 1 (set-size s1) "duplicates not added")
(assert-eq '(5) (set->list s1) "only one element")
(test-end)

(test-begin "set-remove")
(define s1 (set-add (set-add (set-empty) 1) 2))
(define s2 (set-remove s1 1))
(assert-false (set-contains? s2 1) "removed element gone")
(assert-true (set-contains? s2 2) "other element remains")
(define s3 (set-remove s2 99))
(assert-eq (set->list s2) (set->list s3) "remove missing is no-op")
(test-end)

(test-begin "set-union")
(define s1 (list->set '(1 2 3)))
(define s2 (list->set '(2 3 4)))
(define u (set-union s1 s2))
(assert-eq '(1 2 3 4) (set->list u) "union combines all elements")
(test-end)

(test-begin "set-intersection")
(define s1 (list->set '(1 2 3 4)))
(define s2 (list->set '(2 4 6)))
(define i (set-intersection s1 s2))
(assert-eq '(2 4) (set->list i) "intersection keeps common elements")
(test-end)

(test-begin "set-difference")
(define s1 (list->set '(1 2 3 4)))
(define s2 (list->set '(2 4)))
(define d (set-difference s1 s2))
(assert-eq '(1 3) (set->list d) "difference removes second from first")
(test-end)

(test-begin "set-subset")
(define s1 (list->set '(2 4)))
(define s2 (list->set '(1 2 3 4 5)))
(define s3 (list->set '(2 4 6)))
(assert-true (set-subset? s1 s2) "s1 is subset of s2")
(assert-false (set-subset? s3 s2) "s3 is not subset of s2 (has 6)")
(assert-true (set-subset? (set-empty) s1) "empty is subset of all")
(test-end)

(test-begin "set-fold")
(define s1 (list->set '(1 2 3 4)))
(assert-eq 10 (set-fold + 0 s1) "fold with + sums elements")
(test-end)

(test-begin "set-map")
(define s1 (list->set '(1 2 3)))
(define s2 (set-map double s1))
(assert-eq '(2 4 6) (set->list s2) "map doubles elements")
(test-end)

(test-begin "set-filter")
(define s1 (list->set '(1 2 3 4 5 6)))
(define s2 (set-filter even? s1))
(assert-eq '(2 4 6) (set->list s2) "filter keeps evens")
(test-end)

(test-begin "set-immutability")
(define s1 (list->set '(1 2 3)))
(define s2 (set-add s1 4))
(assert-eq 3 (set-size s1) "original unchanged")
(assert-false (set-contains? s1 4) "original does not have new element")
(test-end)

; ============================================================================
; Binary Search Tree Tests
; ============================================================================

(test-begin "bst-basic")
(define t1 (bst-empty))
(assert-eq '() t1 "empty tree is nil")
(define t2 (bst-put t1 5 'five))
(assert-eq 'five (bst-get t2 5) "get after put")
(assert-eq '() (bst-get t2 3) "get missing key returns nil")
(test-end)

(test-begin "bst-multiple")
(define t1 (bst-put (bst-put (bst-put (bst-empty) 5 'five) 3 'three) 7 'seven))
(assert-eq 'five (bst-get t1 5) "get root")
(assert-eq 'three (bst-get t1 3) "get left child")
(assert-eq 'seven (bst-get t1 7) "get right child")
(assert-eq 3 (bst-size t1) "size is 3")
(test-end)

(test-begin "bst-update")
(define t1 (bst-put (bst-empty) 5 'old))
(define t2 (bst-put t1 5 'new))
(assert-eq 'new (bst-get t2 5) "update overwrites value")
(assert-eq 1 (bst-size t2) "size unchanged")
(test-end)

(test-begin "bst-contains")
(define t1 (bst-put (bst-put (bst-empty) 5 'x) 3 'y))
(assert-true (bst-contains? t1 5) "contains root")
(assert-true (bst-contains? t1 3) "contains child")
(assert-false (bst-contains? t1 7) "does not contain missing")
(test-end)

(test-begin "bst-min-max")
(define t1 (bst-put (bst-put (bst-put (bst-empty) 5 'a) 3 'b) 7 'c))
(assert-eq 3 (bst-min t1) "min is 3")
(assert-eq 7 (bst-max t1) "max is 7")
(assert-eq '() (bst-min (bst-empty)) "min of empty is nil")
(assert-eq '() (bst-max (bst-empty)) "max of empty is nil")
(test-end)

(test-begin "bst-keys-values")
(define t1 (bst-put (bst-put (bst-put (bst-empty) 5 'five) 3 'three) 7 'seven))
(assert-eq '(3 5 7) (bst-keys t1) "keys in order")
(assert-eq '(three five seven) (bst-values t1) "values in order")
(test-end)

(test-begin "bst-remove-leaf")
(define t1 (bst-put (bst-put (bst-put (bst-empty) 5 'a) 3 'b) 7 'c))
(define t2 (bst-remove t1 3))
(assert-eq '() (bst-get t2 3) "removed key gone")
(assert-eq 'a (bst-get t2 5) "root still present")
(assert-eq 'c (bst-get t2 7) "other child still present")
(assert-eq 2 (bst-size t2) "size decreased")
(test-end)

(test-begin "bst-remove-one-child")
(define t1 (bst-put (bst-put (bst-empty) 5 'a) 3 'b))
(define t2 (bst-remove t1 5))
(assert-eq '() (bst-get t2 5) "removed root gone")
(assert-eq 'b (bst-get t2 3) "child promoted")
(assert-eq 1 (bst-size t2) "size is 1")
(test-end)

(test-begin "bst-remove-two-children")
(define t1 (bst-put (bst-put (bst-put (bst-empty) 5 'a) 3 'b) 7 'c))
(define t2 (bst-remove t1 5))
(assert-eq '() (bst-get t2 5) "removed root gone")
(assert-eq 'b (bst-get t2 3) "left child present")
(assert-eq 'c (bst-get t2 7) "right child present")
(assert-eq 2 (bst-size t2) "size decreased")
(assert-eq '(3 7) (bst-keys t2) "keys still in order")
(test-end)

(test-begin "bst-height")
(define t1 (bst-empty))
(assert-eq 0 (bst-height t1) "empty tree height is 0")
(define t2 (bst-put t1 5 'a))
(assert-eq 1 (bst-height t2) "single node height is 1")
(define t3 (bst-put (bst-put t2 3 'b) 7 'c))
(assert-eq 2 (bst-height t3) "balanced 3-node tree height is 2")
(test-end)

(test-begin "bst-fold-inorder")
(define t1 (bst-put (bst-put (bst-put (bst-empty) 5 50) 3 30) 7 70))
; Fold that collects values: (acc key val) -> (cons val acc)
(define collect-vals (lambda (acc k v) (cons v acc)))
(define vals (bst-fold-inorder collect-vals '() t1))
; Fold processes in order: 3->5->7, so we get (70 50 30)
(assert-eq '(70 50 30) vals "fold-inorder processes in sorted order")
(test-end)

(test-begin "bst-immutability")
(define t1 (bst-put (bst-empty) 5 'a))
(define t2 (bst-put t1 3 'b))
(assert-eq 1 (bst-size t1) "original unchanged")
(assert-false (bst-contains? t1 3) "original does not have new key")
(test-end)

; ============================================================================
; Heap Tests
; ============================================================================

(test-begin "heap-basic")
(define h1 (heap-empty))
(assert-true (heap-empty? h1) "empty heap is empty")
(define h2 (heap-insert h1 5))
(assert-false (heap-empty? h2) "non-empty heap is not empty")
(assert-eq 5 (heap-find-min h2) "find-min returns inserted value")
(test-end)

(test-begin "heap-min-property")
(define h1 (heap-insert (heap-insert (heap-insert (heap-empty) 5) 3) 7))
(assert-eq 3 (heap-find-min h1) "min is smallest inserted value")
(test-end)

(test-begin "heap-delete-min")
(define h1 (heap-insert (heap-insert (heap-insert (heap-empty) 5) 3) 7))
(define h2 (heap-delete-min h1))
(assert-eq 5 (heap-find-min h2) "after delete-min, next smallest is min")
(define h3 (heap-delete-min h2))
(assert-eq 7 (heap-find-min h3) "after another delete-min")
(define h4 (heap-delete-min h3))
(assert-true (heap-empty? h4) "after all deletes, heap is empty")
(test-end)

(test-begin "heap-merge")
(define h1 (heap-insert (heap-insert (heap-empty) 1) 5))
(define h2 (heap-insert (heap-insert (heap-empty) 3) 7))
(define merged (heap-merge h1 h2))
(assert-eq 4 (heap-size merged) "merged has all elements")
(assert-eq 1 (heap-find-min merged) "merged min is overall min")
(test-end)

(test-begin "heap-size")
(define h1 (heap-empty))
(assert-eq 0 (heap-size h1) "empty heap size is 0")
(define h2 (heap-insert (heap-insert (heap-insert h1 5) 3) 7))
(assert-eq 3 (heap-size h2) "size after 3 inserts")
(define h3 (heap-delete-min h2))
(assert-eq 2 (heap-size h3) "size after delete")
(test-end)

(test-begin "list->heap")
(define h1 (list->heap '(5 3 7 1 9)))
(assert-eq 5 (heap-size h1) "heap has all list elements")
(assert-eq 1 (heap-find-min h1) "min is list minimum")
(test-end)

(test-begin "heap->sorted-list")
(define h1 (list->heap '(5 3 7 1 9)))
(define sorted (heap->sorted-list h1))
(assert-eq '(1 3 5 7 9) sorted "heap->sorted-list produces sorted list")
(test-end)

(test-begin "heapsort")
(assert-eq '(1 2 3 4 5) (heapsort '(5 3 1 4 2)) "heapsort sorts list")
(assert-eq '() (heapsort '()) "heapsort empty list")
(assert-eq '(42) (heapsort '(42)) "heapsort singleton")
(assert-eq '(1 2 2 3) (heapsort '(2 3 1 2)) "heapsort with duplicates")
(test-end)

(test-begin "heap-immutability")
(define h1 (heap-insert (heap-empty) 5))
(define h2 (heap-insert h1 3))
(assert-eq 1 (heap-size h1) "original unchanged after insert")
(assert-eq 5 (heap-find-min h1) "original min unchanged")
(test-end)

(test-begin "heap-edge-cases")
(assert-eq '() (heap-find-min (heap-empty)) "find-min of empty is nil")
(assert-eq '() (heap-delete-min (heap-empty)) "delete-min of empty is nil")
(test-end)

(test-summary)
