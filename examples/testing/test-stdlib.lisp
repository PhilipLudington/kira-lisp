; Tests for the standard library

(import "src/stdlib.lisp")

; Define test helper functions upfront to avoid Kira closure bugs
(define double (lambda (x) (* x 2)))
(define square (lambda (x) (* x x)))
(define identity-fn (lambda (x) x))
(define even? (lambda (x) (= (mod x 2) 0)))
(define always-false (lambda (x) #f))
(define always-true (lambda (x) #t))
(define cons-to-front (lambda (acc x) (cons x acc)))
(define positive? (lambda (x) (> x 0)))
(define gt2? (lambda (x) (> x 2)))
(define gt5? (lambda (x) (> x 5)))
(define gt10? (lambda (x) (> x 10)))
(define inc (lambda (x) (+ x 1)))

(test-reset)

(test-begin "map")
(assert-eq '(2 4 6) (map double '(1 2 3)) "double each element")
(assert-eq '() (map identity-fn '()) "map over empty list")
(assert-eq '(1 4 9) (map square '(1 2 3)) "square each element")
(test-end)

(test-begin "filter")
(assert-eq '(2 4) (filter even? '(1 2 3 4 5)) "keep evens")
(assert-eq '() (filter always-false '(1 2 3)) "filter all out")
(assert-eq '(1 2 3) (filter always-true '(1 2 3)) "keep all")
(assert-eq '() (filter identity-fn '()) "filter empty list")
(test-end)

(test-begin "foldl/reduce")
(assert-eq '(3 2 1) (foldl cons-to-front '() '(1 2 3)) "foldl reverses")
(assert-eq 15 (foldl + 0 '(1 2 3 4 5)) "sum with foldl")
(assert-eq 120 (foldl * 1 '(1 2 3 4 5)) "product with foldl")
(assert-eq 0 (foldl + 0 '()) "foldl on empty list")
(assert-eq 15 (reduce + 0 '(1 2 3 4 5)) "reduce alias works")
(test-end)

(test-begin "foldr")
(assert-eq 15 (foldr + 0 '(1 2 3 4 5)) "sum with foldr")
(assert-eq '(1 2 3) (foldr cons '() '(1 2 3)) "foldr preserves order")
(assert-eq 0 (foldr + 0 '()) "foldr on empty list")
(test-end)

(test-begin "take")
(assert-eq '(1 2 3) (take 3 '(1 2 3 4 5)) "take first 3")
(assert-eq '(1 2) (take 5 '(1 2)) "take more than available")
(assert-eq '() (take 0 '(1 2 3)) "take 0")
(assert-eq '() (take 3 '()) "take from empty")
(test-end)

(test-begin "drop")
(assert-eq '(4 5) (drop 3 '(1 2 3 4 5)) "drop first 3")
(assert-eq '() (drop 5 '(1 2)) "drop more than available")
(assert-eq '(1 2 3) (drop 0 '(1 2 3)) "drop 0")
(assert-eq '() (drop 3 '()) "drop from empty")
(test-end)

(test-begin "append")
(assert-eq '(1 2 3 4) (append '(1 2) '(3 4)) "append two lists")
(assert-eq '(1 2) (append '(1 2) '()) "append empty second")
(assert-eq '(3 4) (append '() '(3 4)) "append empty first")
(assert-eq '() (append '() '()) "append both empty")
(test-end)

(test-begin "reverse")
(assert-eq '(3 2 1) (reverse '(1 2 3)) "reverse list")
(assert-eq '() (reverse '()) "reverse empty")
(assert-eq '(1) (reverse '(1)) "reverse singleton")
(test-end)

(test-begin "nth")
(assert-eq 1 (nth 0 '(1 2 3)) "nth first element")
(assert-eq 2 (nth 1 '(1 2 3)) "nth second element")
(assert-eq 3 (nth 2 '(1 2 3)) "nth last element")
(assert-eq '() (nth 5 '(1 2 3)) "nth out of bounds")
(test-end)

(test-begin "last")
(assert-eq 3 (last '(1 2 3)) "last of list")
(assert-eq 1 (last '(1)) "last of singleton")
(assert-eq '() (last '()) "last of empty")
(test-end)

(test-begin "flatten")
(assert-eq '(1 2 3 4) (flatten '((1 2) (3 4))) "flatten nested")
(assert-eq '(1 2 3) (flatten '(1 2 3)) "flatten flat list")
(assert-eq '(1 2 3 4 5) (flatten '((1) 2 (3 4) 5)) "flatten mixed")
(assert-eq '() (flatten '()) "flatten empty")
(test-end)

(test-begin "every?")
(assert-true (every? positive? '(1 2 3)) "all positive")
(assert-false (every? positive? '(1 -2 3)) "not all positive")
(assert-true (every? identity-fn '()) "every? on empty is true")
(test-end)

(test-begin "some?")
(assert-true (some? gt2? '(1 2 3)) "some greater than 2")
(assert-false (some? gt5? '(1 2 3)) "none greater than 5")
(assert-false (some? identity-fn '()) "some? on empty is false")
(test-end)

(test-begin "none?")
(assert-true (none? gt5? '(1 2 3)) "none greater than 5")
(assert-false (none? gt2? '(1 2 3)) "some greater than 2")
(assert-true (none? identity-fn '()) "none? on empty is true")
(test-end)

(test-begin "find")
(assert-eq 3 (find gt2? '(1 2 3 4)) "find first > 2")
(assert-eq '() (find gt10? '(1 2 3)) "find nothing")
(assert-eq '() (find identity-fn '()) "find in empty")
(test-end)

(test-begin "member?")
(assert-true (member? 2 '(1 2 3)) "2 is member")
(assert-false (member? 5 '(1 2 3)) "5 is not member")
(assert-false (member? 1 '()) "nothing in empty")
(test-end)

(test-begin "sum")
(assert-eq 15 (sum '(1 2 3 4 5)) "sum of 1-5")
(assert-eq 0 (sum '()) "sum of empty")
(assert-eq 42 (sum '(42)) "sum of singleton")
(test-end)

(test-begin "product")
(assert-eq 120 (product '(1 2 3 4 5)) "product of 1-5")
(assert-eq 1 (product '()) "product of empty")
(assert-eq 42 (product '(42)) "product of singleton")
(test-end)

(test-begin "clamp")
(assert-eq 5 (clamp 0 10 5) "clamp in range")
(assert-eq 0 (clamp 0 10 -5) "clamp below min")
(assert-eq 10 (clamp 0 10 15) "clamp above max")
(test-end)

(test-begin "compose")
(assert-eq 7 ((compose inc double) 3) "compose inc and double: (3*2)+1")
(assert-eq 8 ((compose double inc) 3) "compose double and inc: (3+1)*2")
(test-end)

(test-begin "identity")
(assert-eq 5 (identity 5) "identity number")
(assert-eq '(1 2) (identity '(1 2)) "identity list")
(test-end)

(test-begin "constantly")
(define always-42 (constantly 42))
(assert-eq 42 (always-42 'ignored) "constantly ignores argument")
(assert-eq 42 (always-42 999) "constantly returns same value")
(test-end)

(test-begin "zip")
(assert-eq '((1 a) (2 b) (3 c)) (zip '(1 2 3) '(a b c)) "zip equal length")
(assert-eq '((1 a) (2 b)) (zip '(1 2 3) '(a b)) "zip unequal length")
(assert-eq '() (zip '() '(1 2 3)) "zip with empty first")
(assert-eq '() (zip '(1 2 3) '()) "zip with empty second")
(test-end)

(test-begin "range")
(assert-eq '(0 1 2 3 4) (range 0 5) "range 0 to 5")
(assert-eq '(3 4 5) (range 3 6) "range 3 to 6")
(assert-eq '() (range 5 5) "range empty when equal")
(assert-eq '() (range 5 3) "range empty when start > end")
(test-end)

(test-summary)
